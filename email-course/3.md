# How To Write Maintainable Tests

One of the biggest challenges with Selenium tests is that they can be brittle and challenging to maintain over time. This is largely due to the fact that things in the application you're testing change, causing your tests to break.

But the reality of a software project is that _change is a constant_. So we need to account for this reality somehow in our test code in order to be successful.

Enter Page Objects.

## A Page Objects Primer

Rather than write your test code directly against your app, you can model the behavior of your application into simple objects and write your tests against them instead. That way when your app changes and your tests break, you only have to update your test code in one place to fix it.

With this approach, we not only get the benefit of controlled chaos, we also get reusable functionality across our suite of tests (as well as more readable tests).

Let's step through an example.

## An Example

### Part 1: Create A Page Object And Update Test

Let's take our login example from earlier, create a page object for it, and update our test accordingly.

First we'll need to create a package called `pageobjects` in our `src/tests/java` directory. Then let's add a file to the `pageobjects` package called `Login.java`. When we're done our directory structure should look like this.

```text
├── pom.xml
├── src
│   └── test
│       └── java
│           ├── pageobjects
│           │   └── Login.java
│           └── tests
│               └── TestLogin.java
```

And here's the code that goes with it.

```java
// filename: pageobjects/Login.java

package pageobjects;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;

public class Login {

    private WebDriver driver;
    By usernameLocator  = By.id("username");
    By passwordLocator  = By.id("password");
    By submitButton     = By.cssSelector("button");
    By successMessageLocator = By.cssSelector(".flash.success");

    public Login(WebDriver driver) {
        this.driver = driver;
        driver.get("http://the-internet.herokuapp.com/login");
    }

    public void with(String username, String password) {
        driver.findElement(usernameLocator).sendKeys(username);
        driver.findElement(passwordLocator).sendKeys(password);
        driver.findElement(submitButton).click();
    }

    public Boolean successMessagePresent() {
        return driver.findElement(successMessageLocator).isDisplayed();
    }

}
```

At the top of the file we specify the package where it lives and import the requisite classes from our libraries. We then declare the class (e.g., `public class Login`), specify our field variables (for the Selenium instance and the page's locators), and add three methods.

The first method (e.g., `public Login(WebDriver driver)`) is the constructor. It will run whenever a new instance of the class is created. In order for this class to work we need access to the Selenium driver object, so we accept it as a parameter here and store it in the `driver` field (so other methods can access it). Then the login page is visited (with `driver.get`).

The second method (e.g., `public void with(String username, String password)`) is the core functionality of the login page. It's responsible for filling in the login form and submitting it. By accepting strings parameters for the username and password we're able to make the functionality here dynamic and reusable for additional tests.

The last method (e.g., `public Boolean successMessagePresent()`) is the display check from earlier that was used in our assertion. It will return a Boolean result just like before.

Now let's update our test to use this page object.

```java
// filename: tests/TestLogin.java

package tests;

import org.junit.Test;
import org.junit.Before;
import org.junit.After;
import static org.junit.Assert.*;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import pageobjects.Login;

public class TestLogin {

    private WebDriver driver;
    private Login login;

    @Before
    public void setUp() {
        driver = new FirefoxDriver();
        login = new Login(driver);
    }

    @Test
    public void succeeded() {
        login.with("tomsmith", "SuperSecretPassword!");
        assertTrue("success message not present",
                login.successMessagePresent());
    }

    @After
    public void tearDown() {
        driver.quit();
    }
}
```

Since the page object lives in another package, we need to import it (e.g., `import pageobjects.Login;`).

Then it's a simple matter of specifying a field for it (e.g., `private Login login`), creating an instance of it in our `setUp` method (passing the `driver` object to it as an argument), and updating the test with the new actions.

Now the test is more concise and readable. If you save this and run it (e.g., `mvn clean test` from the command-line), it will run and pass just like before.

### Part 2: Write Another Test

Creating a page object may feel like more work than what we started with initially. But it's well worth the effort since we're in a much sturdier position (remember: controlled chaos) and able easily write follow-on tests (since the specifics of the page are abstracted away for simple reuse).

Let's add another test for a failed login to demonstrate.

First, let's take a look at the markup that gets rendered when we provide invalid credentials:

```html
<div id="flash-messages" class="large-12 columns">
  <div data-alert="" id="flash" class="flash error">
    Your username is invalid!
    <a href="#" class="close">x</a>
  </div>
</div>
```

Here is the element we'll want to use.

```html
class="flash error"
```

Let's add a locator to our page object along with a new method to perform a display check against it.

```java
//filename: pageobjects/Login.java
// ...
    By successMessageLocator = By.cssSelector(".flash.success");
    By failureMessageLocator = By.cssSelector(".flash.error");
// ...
    public Boolean successMessagePresent() {
        return driver.findElement(successMessageLocator).isDisplayed();
    }

    public Boolean failureMessagePresent() {
        return driver.findElement(failureMessageLocator).isDisplayed();
    }
}
```

Now we're ready to add another test to check for a failure condition.

```java
//filename: tests/TestLogin.java
// ...
@Test
    public void failed() {
        login.with("tomsmith", "bad password");
        assertTrue("failure message wasn't present after providing bogus credentials",
                login.failureMessagePresent());
    }
// ...
```

If we save these changes and run our tests (`mvn clean test`) we will see two browser windows open (one after the other) testing for successful and failure login scenarios.

## Outro

With Page Objects you'll be able to easily maintain and extend your tests. But how you write your Page Objects may vary depending on your preference/experience. The example demonstrated above is a simple approach. Here are some additional resources to consider as your testing practice grows:

+ [Page Objects documentation from the Selenium project](https://github.com/SeleniumHQ/selenium/wiki/PageObjects)
+ [Page Factory](https://github.com/SeleniumHQ/selenium/wiki/PageFactory) (a Page Object generator/helper built into Selenium)
+ [HTML Elements](https://github.com/yandex-qatools/htmlelements) (a simple Page Object framework by Yandex)

Now that you understand how to write maintainable tests with page objects, you're ready to dive into the next lesson: writing resilient tests.
