# Writing Resilient Test Code

Ideally, you should be able to write your tests once and run them across all supported browsers. While this is a rosy proposition, there is some work to make this a reliable success. And sometimes there may be a hack or two involved. But the lengths you must go really depends on the browsers you care about and the functionality you're dealing with.

By using high quality locators we are already well ahead of the pack, but there are still some persnickity issues to deal with. Most notably... timing. This is especially true when working with dynamic, JavaScript heavy pages (which is more the rule than the exception in a majority of web applications you'll deal with).

But there is a simple approach that makes up the bedrock of reliable and resilient Selenium tests -- and that's how you wait and interact with elements. Gone are the days of waiting for the page to finish loading, or hard-coding sleeps, or doing blanket wait times (a.k.a. implicit waits). Nay. Now are the wonder years of waiting for an expected outcome (e.g., waiting for an element to appear) for a specific amount of time.

We accomplish this through the use of __explicit waits__.

## An Example

Let's step through an example that demonstrates this against [a dynamic page on the-internet](http://the-internet.herokuapp.com/dynamic_loading/1). The functionality is pretty simple -- there is a button. When you click it a loading bar appears for 5 seconds, after which it disappears and is replaced with the text 'Hello World!'.

### Part 1: Create A New Page Object And Update The Base Page Object

Here's the markup on the page.

```html
<div class="example">
  <h3>Dynamically Loaded Page Elements</h3>
  <h4>Example 1: Element on page that is hidden</h4>

  <br>

  <div id="start">
    <button>Start</button>
  </div>

  <div id="finish" style="display:none">
    <h4>Hello World!</h4>
  </div>

</div>
```

At a glance it's simple enough to tell that there are unique `id` attributes that we can use to find and click on the start button and verify the finish text.

<!-- mention of page object first vs test first approach -->

Let's create a new page object file called `DynamicLoading.java` in the `pageobjects` package of the `src/test/java` directory.

```sh
.
├── pom.xml
├── src
│   └── test
│       └── java
│           ├── pageobjects
│           │   ├── Base.java
│           │   ├── DynamicLoading.java
│           │   └── Login.java
│           └── tests
│               └── TestLogin.java
```

And in it we'll established inheritance to the base page object and specify the locators and behavior we'll want to use.

```java
// filename: pageobjects/DynamicLoading.java

package pageobjects;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;

public class DynamicLoading extends Base {

    By startButton = By.cssSelector("#start button");
    By finishText  = By.id("finish");

    public DynamicLoading(WebDriver driver) {
        super(driver);
    }

    public void loadExample(String exampleNumber) {
        visit("http://the-internet.herokuapp.com/dynamic_loading/" + exampleNumber);
        click(startButton);
    }

    public Boolean finishTextPresent() {
        return isDisplayed(finishText);
    }

}
```

Since there are two examples to choose from, we'll want to a simple way to load either one. So we created `loadExample`, which accepts the example number as a parameter. And similar to our login page object, we have a display check for the finish text (e.g., `finishTextPresent()`).

Now let's update our base page object to enable explicit waits and wire them up to `isDisplayed`.

```java
// filename: pageobjects/Base.java
...
    public Boolean isDisplayed(By locator, Integer... timeout) {
        try {
            waitFor(ExpectedConditions.visibilityOfElementLocated(locator),
                (timeout.length > 0 ? timeout[0] : null));
        } catch (org.openqa.selenium.NoSuchElementException exception) {
            return false;
        } catch (org.openqa.selenium.TimeoutException exception) {
            return false;
        }
        return true;
    }

    private void waitFor(ExpectedCondition<WebElement> condition, Integer timeout) {
        timeout = timeout != null ? timeout : 5;
        WebDriverWait wait = new WebDriverWait(driver, timeout);
        wait.until(condition);
    }
}
``

<!-- description -->`

## More On Explicit Waits

It's important to set a _reasonably sized_ default timeout for the explicit wait. But you want to be careful not to make it too high. Otherwise you run into a lot of the same timing issues you get from implicit waits. But set it too low and your tests will be brittle, forcing you to run down trivial and transient issues.

In our page object when we're using `` we are telling Selenium to to see if the finish text is displayed on the page. It will keep trying until it either returns `true` or reaches ten seconds -- whichever comes first.

If the behavior on the page takes longer than we expect (e.g., due to slow load times, or a feature change), we can simply adjust this one wait time to fix the test -- rather than increase a blanket wait time (which impacts every test). And since it's dynamic, it won't always take the full amount of time to complete.

<!-- mention of not mixing explicit and implicit waits -->

### Part 2: Write A Test To Use The New Page Object

Now that we have our new page object and updated base page, let's add a test to use them.

Let's create a new file called `TestDynamicLoading.java` in the `tests` package of the `src/test/java` directory.

```sh
.
├── pom.xml
├── src
│   └── test
│       └── java
│           ├── pageobjects
│           │   ├── Base.java
│           │   ├── DynamicLoading.java
│           │   └── Login.java
│           └── tests
│               ├── TestDynamicLoading.java
│               └── TestLogin.java
```

<!-- lead in -->

```java
// filename: tests/TestDynamicLoading.java

package tests;

import org.junit.Test;
import org.junit.Before;
import org.junit.After;
import static org.junit.Assert.*;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import pageobjects.DynamicLoading;

public class TestDynamicLoading {

    private WebDriver driver;
    private DynamicLoading dynamicLoading;

    @Before
    public void setUp() {
        driver = new FirefoxDriver();
        dynamicLoading = new DynamicLoading(driver);
    }

    @Test
    public void hiddenElementLoads() {
        dynamicLoading.loadExample("1");
        assertTrue("finish text didn't display after loading",
                dynamicLoading.finishTextPresent());
    }

    @After
    public void tearDown() {
        driver.quit();
    }
}
```

<!-- description -->

When we run this test (`mvn clean test -Dtest=TestDynamicLoading` from the command-line) it will run, wait for the loading bar to complete, and pass.

### Part 3: Update Page Object And Add A New Test

Let's step through one more dynamic page example to see if our explicit wait approach holds up.

[This example](http://the-internet.herokuapp.com/dynamic_loading/2) is laid out similarly to the last one, the main difference is that it will render the final result __after__ the progress bar completes. Here's the markup for it.

```html
<div class="example">
  <h3>Dynamically Loaded Page Elements</h3>
  <h4>Example 2: Element rendered after the fact</h4>

  <br>

  <div id="start">
    <button>Start</button>
  </div>

  <br>
</div>
```

In order to find the selector for the finish text element we need to inspect the page after the loading bar sequence finishes. Here's what it looks like.

```html
<div id="finish" style=""><h4>Hello World!</h4></div>
```

<!-- lead in -->

```java
// filename: tests/TestDynamicLoading.java
...
    @Test
    public void hiddenElementLoads() {
        dynamicLoading.loadExample("1");
        assertTrue("finish text didn't display after loading",
                dynamicLoading.finishTextPresent());
    }

    @Test
    public void elementAppears() {
        dynamicLoading.loadExample("2");
        assertTrue("finish text didn't render after loading",
                dynamicLoading.finishTextPresent());
    }
...
```

<!-- description -->

When we run both tests (`mvn clean test -Dtests=TestDynamicLoading` from the command-line) then we can see that the same approach will work for both cases.

## Browser Timing

Using explicit waits gets you pretty far. But there are a few things you'll want to think about when it comes to writing your tests to work against various browsers.

It's simple enough to write your tests locally against Firefox and assume you're all set. Once you start to run things against other browsers, you may be in for a rude awakening. The first thing you're likely to run into is the speed of execution. A lot of your tests will start to fail when you point them at either Chrome or Internet Explorer, and likely for different reasons.

In my experience, Chrome execution is very fast, so you will see some odd timeout failures. This is an indicator that you need to add explicit waits to parts of your page objects that don't already have them. And the inverse is true when running things against older version of Internet Explorer (e.g., IE 8). This is an indicator that your explicit wait times are not long enough since the browser is taking longer to respond -- so your tests timeout.

The best approach to solve this is an iterative one. Run your tests and find the failures. Take each failed test, adjust your code as needed, and run it against the browsers you care about. Repeat until you make a pass all the way through each of the failed tests. Then run a batch of all your tests to see where they fall down. Repeat until everything's green.

Once you're on the other side of these issues, the amount of effort you need to put into it should diminish dramatically.

## Closing Thoughts

By explicitly waiting to complete an action, our tests are in a much more resilient position because Selenium will keep trying for a reasonable amount of time rather than trying just once. And each action can be tuned to meet the needs of each circumstance. Couple that with the dynamic nature of explicit waits, and you have something that will work in a multitude of circumstances -- helping you endure even the toughest of browsers to automate.

This is one of the most important concepts in testing with Selenium. Use explicits waits often.
