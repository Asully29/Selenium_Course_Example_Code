# A Programming Primer

This section will prime you with just enough programming concepts (and how they pertain to testing) to get you going so you have some working knowledge and a vocabulary. This will enable you to more effectively comprehend what you will see throughout this book (and in your work afterwards).

Don't get too hung up on the details though. If something doesn't make sense, it should once we dig into the full examples in the following chapters. Consider this more of a glossary than a code school.

## Installation

TODO

## Installing Third-Party Libraries

TODO

## Choosing An IDE (Integrated Development Environment)

TODO

## Programming Concepts In A Nutshell

Programming can be a deep and intimidating rabbit hole if you're new to it. But don't worry. When it comes to testing there is only a small subset of programming that we really need to get started. Granted, the more you know, the better off you'll be. But you don't need to know a whole lot to be an effective test automator right now.

Of all the programming concepts out there, here are the ones you'll need to pay attention to first:

+ Object Structures (Variables, Methods, and Classes)
+ Access (pubic, protected, private)
+ Object Types (Strings, Integers, Booleans, etc.)
+ Actions (Assertions and Conditionals)
+ Annotations
+ Inheritance

Let's step through each and how they pertain to testing with Selenium.

### Object Structures

#### Variables

Variables are objects where you can store and retrieve values. They are created and referenced by a name that:

+ is case-sensitive
+ must not be a keyword (or reserved word)
+ starts with a letter

If the variable name is one word, it should be all lowercase. If it's more than one word it should be [CamelCase](http://en.wikipedia.org/wiki/CamelCase) (e.g., `exampleVariable`).

You can store a value in a variable by using an equals sign (e.g., `=`). But you'll only be able to store a value of the type you specified when creating the variable.

```java
String exampleVariable1 = "string value";
System.out.println(exampleVariable1.getClass());
// outputs: class java.lang.String

Integer exampleVariable2 = 42;
System.out.println(exampleVariable2.getClass());
// outputs: class java.lang.Integer
```

__NOTE: In the code snippet above we're using `System.out.println();` to output a message. This is a common command that is useful for generating output to the console (a.k.a. terminal).__

In Selenium, a common example of a variable is storing an element (or a value from an element) in the beginning of a test to be referenced later. For example, getting a page's title.

```java
String pageTitle = driver.getTitle();
```

__NOTE: `driver` is the variable we will use to interact with Selenium throughout the book. More on that later.__

#### Methods

Throughout our tests we'll want to group common actions and behavior together for easy reuse. We do this by placing them into methods. We define a method within a class (more on those next) by specifying a modifier, a return type, and a name.

We'll cover modifiers in `Scope`, for now you can just set it to `public`. A return type is used to specify what type of an object you want to return after the method is run. If you don't want to return anything, specify the return type as `void`.

Method naming follows similar conventions to variables. The main difference being that they tend to start with a verb (since they denote some kind of an action to be performed). Also, the contents (e.g., the body) of the method are wrapped in opening and closing brackets (e.g., `{}`).

```java
public void sayHello() {
  // your code goes here
}
```

Additionally, you can make a method accept an argument when calling it. This is done with a parameter.

```java
public void sayHello(String message) {
  System.out.println(message);
}
```

We'll see methods put to use in numerous places in our test code. First and foremost each of our tests will use them when setting up and tearing down instances of Selenium.

```java
public void setUp() {
    driver = new FirefoxDriver();
}

public void tearDown() {
    driver.quit();
}
```

#### Classes

Classes are a useful way to store the state and behavior of something complex for reuse. They can contain variables and methods, and are defined with the word `class` followed by the name you wish to give it.

Class names:

+ must match the name of the file they're stored in
+ should be CamelCase for multiple words (e.g., class ExampleClass)
+ should be descriptive

You first have to define a class, and then create an instance of it (a.k.a. instantiation) in order to use it. Once you have this instance, you can access the methods within it to trigger an action.

The most common example of this in Selenium is when you want to represent a part of your web page (a.k.a. a page object). In the class you store the elements on the page (e.g., state) and the actions you can do on the page (e.g., behavior).

```java
// code in page object class
public class Login {

    private WebDriver driver;
    By usernameLocator  = By.id("username");
    By passwordLocator  = By.id("password");
    By loginFormLocator = By.id("login");

    public void with(String username, String password) {
...
// code in test that uses the page object
Login login = new Login
login.with("username", "password"):
```

### Access

When specifying an object (e.g., a variable, method, or class) you can apply a modifier. This modifier denotes what else can access the object. This is also known as "scope".

For classes you can apply `public` or nothing. `public` makes the class visible to all other classes. Specifying nothing makes it visible only to classes within the same package (e.g., a package is a way to group related classes together under a simple name).

For members of a class (e.g., variables and methods) you can use `public`, `private`, `protected`, and nothing. `public` and nothing are the same as with classes. `private` makes it so the member can only be accessed from within the class that it was created. `protected` makes it so it can be accessed by other classes in the same package (which is the same as specifying nothing).

The best thing to do is to follow a "need-to-know" principle for your objects. Start with a `private` scope and only elevate it if needbe (e.g., from `private` to `protected`, from `protected` to `public`, etc.).

In our Selenium tests, we'll end up with various modifiers for our objects.

```java
// When creating a test class it needs to be public for JUnit to use it
public class TestLogin {

    // Our Selenium object should only be accessed from within the same class
    private WebDriver driver;
```

### Types

Objects can be of various types. And when declaring a method, we need to specify what type it will return. If it returns nothing, we specify `void`. But if it returns something (e.g., a Boolean) then we need to specify it.

The two most common types we'll see initially in our tests are Strings and Booleans. Strings are a series of alpha-numeric characters stored in double-quotes. Booleans store a result which is either `true` or `false`.

A common example of specifying a return type in our test code is when we use Selenium to see if something is displayed on a page.

```java
public Boolean successMessagePresent() {
    return isDisplayed(successMessageLocator);
}
```

### Actions

A benefit of booleans is that we can use their value (e.g., `true` or `false`) to perform an assertion. An assertion is a function that allows us to test assumptions about our application.

For instance, in our test we could be testing the login functionality of our application. After logging in, we could check to see if something specific is displayed on the page (e.g., a sign out button, a success notification, etc.). This display check would return a boolean, and we would use it to assert that it is what we expect.

```java
// method in a page object that looks to see if a success message is displayed after logging in
    public Boolean successMessagePresent() {
        return isDisplayed(successMessageLocator);
    }

// assertion in our test that checks to see if the value returned is the value expected
    assertTrue("success message not present", login.successMessagePresent());
```

In addition to assertions, we can also leverage booleans in conditionals. Conditionals (a.k.a. control flow statements) are a way to break up the flow of code so that only certain chunks of it are executed based on predefined criteria. The most common control flow statements we'll use are `if`, `else if`, and `else`.

The most common use of this will be in how we configure Selenium to run a different browser.

```java
    if (browser.equals("firefox")) {
        driver = new FirefoxDriver();
    } else if (browser.equals("chrome")) {
        System.setProperty("webdriver.chrome.driver",
                System.getProperty("user.dir") + "/vendor/chromedriver");
        driver = new ChromeDriver();
    }
```

__NOTE: The commands `System.setProperty` and `System.getProperty` are used to set and retrieve runtime properties in Java. This is a handy function to know since it comes built into Java and it enables you to easily create and retrieve values when running your tests.__

## Annotations

Annotations are a form of metadata that, by themselves, have no direct impact on the code they reference. However, they are used by various libraries to enable additional functionality.

The most common use of annotations in Selenium tests are when specifying different types of methods (e.g., a setup method, a teardown method, a test method, etc.).

```java
// methods in a test class file
@Before
    public void setUp() {
...
@Test
    public void descriptiveTestName() {
...
@After
    public void tearDown() {
```

### Inheritance

Classes have the ability to connect to one-another through parent/child inheritance. By having a single parent class we can store common actions in methods that can be readily available to all child classes.

Inheritance is done when declaring a child class by:

+ providing the class name
+ using the `extends` keyword
+ providing the name of the parent class

```java
public class Parent {

  static String hairColor = "brown";

}

public class Child extends Parent {
  public static void main(String[] args) {
    System.out.println(hairColor);
  }
}

// running the Child class outputs "brown"
```

We'll see this in our tests when writing all of the common Selenium actions we intend to use into methods within a parent class (a.k.a. a base page object or facade layer). Inheriting this class will allow us to call these methods in our child classes (e.g., page objects). More on this in Chapter 9.

## Additional Resources

+ [Oracle Java Tutorials](http://docs.oracle.com/javase/tutorial/)
+ [tutorialspoint](http://www.tutorialspoint.com/java/)
+ [Java Tutorial for Complete Beginners (video course on Udemy)](https://www.udemy.com/java-tutorial/)
+ [Java In a Nutshell](http://www.amazon.com/Java-Nutshell-Benjamin-J-Evans/dp/1449370829)
+ [Java For Testers](https://leanpub.com/javaForTesters)
