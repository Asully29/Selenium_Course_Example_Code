# Speeding Up Your Test Runs

We've made huge strides by leveraging page objects, a base page object, explicit waits, and connecting our tests to Sauce Labs. But we're not done yet. Our tests still take a good deal of time to run since they're executing in series (e.g., one after another). As our suite grows this slowness will grow with it.

With parallelization we can easily remedy this pain before it becomes acute by executing multiple tests at the same time. And with [the Maven Surefire Plugin](http://maven.apache.org/surefire/maven-surefire-plugin/) it's extremely simple to setup.

## Part 1: Setup

The installation and configuration for the Maven Surefire Plugin starts and ends in the `pom.xml` file. Here is what we need to add to it:

```java
// filename: pom.xml
...
    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <version>2.18.1</version>
                    <configuration>
                        <parallel>classesAndMethods</parallel>
                        <threadCount>5</threadCount>
                    </configuration>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>

</project>
```

Notice that there's no `<dependency>` section for installing this library. Everything is handled within the `<build><pluginManagement>` section. And aside from specifying a `groupId`, `artifactId`, and `version` we have a `configuration` section. In this section we've set the type of `parallel` execution we want (e.g., `classesAndMethods`) along with the number of concurrent threads we'd like to use (e.g., `5`).

When we save this file and run our tests (e.g., `mvn clean test`) we'll see multiple browsers launch at the same time -- completing a run through all of the tests at a much faster rate than before.

For a more thorough explanation of parallel execution with the Maven Surefire Plugin and the other options available, go [here](http://maven.apache.org/surefire/maven-surefire-plugin/examples/fork-options-and-parallel-execution.html).

## Part 2: Randomizing

When enabling parallel execution in your tests you may start to see odd, inconsistent behavior that is hard to track down.

This is often due to dependencies between tests that you didn't know were there. A great way to expose these kinds of issues and ensure your tests are ready for prime time is to execute them in a random order. This also has the added benefit of exercising the application you're testing in a random order (which could unearth previously unnoticed bugs).

Luckily, there is a library to enable this and setting it up is another simple change. After installing [`random-jUnit`](http://randomjunit.sourceforge.net/) we just need to add an annotation to our base test class.

```java
// filename: pom.xml
...
        <dependency>
            <groupId>net.sf.randomjunit</groupId>
            <artifactId>random-jUnit</artifactId>
            <version>1.0.2</version>
        </dependency>

    </dependencies>
...
```

This library requires no additional configuration in the `pom.xml`. It's just a standard installation. Now to modify the base test class.

```java
// filename: tests/Base.java
...
import net.sf.randomjunit.RandomTestRunner;

@RunWith(RandomTestRunner.class)
public class Base implements Config {
...
```

After importing the library we use JUnit's `@RunWith` annotation to use the `RandomTestRunner.class` (which is made available by the random-jUnit library library). For more information on the JUnit's @RunWith annotation, go [here](https://github.com/junit-team/junit/wiki/Test-runners#runwith-annotation).

Now when we run our tests (e.g., `mvn clean test` from the command-line) they will run in a random order.
