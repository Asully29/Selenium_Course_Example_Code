# Frames

More often than not you'll run into a throwback relic of the front-end world -- in this case, frames. Rather than curse and spit when it comes to writing automated tests against them, there is a simple approach we can use to tap dance through them.

In order to access the elements within a frame we need to tell Selenium to switch to it.

Let's demonstrate this with a couple of test scripts.

## An Example

Our general script setup is pretty straightforward. Nothing special -- just the standard setup, teardown, and run methods.

```ruby
require 'selenium-webdriver'
require 'rspec-expectations'

def setup
  @driver = Selenium::WebDriver.for :firefox
end

def teardown
  @driver.quit
end

def run
  setup
  yield
  teardown
end
```

Our first example demonstrates how to deal with nested frames. You can see the page we are testing against [here](http://the-internet.herokuapp.com/frames). But here is a simple representation of it:

```sh
| - frameset
    | - top frame
        | - frameset
            | - left
            | - middle
            | - right
    | - bottom frame
```

```ruby
# Nested Frames
run {
  @driver.get 'http://the-internet.herokuapp.com/frames'
  @driver.switch_to.frame('frame-top')
    @driver.switch_to.frame('frame-middle')
      @driver.find_element(id: 'content').text.should =~ /MIDDLE/
}
```

In order to get the text of the middle frame, we need to switch to it. But in order for Selenium to see it, we need to switch to the parent frame first, then the child frame.

Once we've done that, we are able to freely find the element we want and assert that the relevant text appears.

While this example helps illustrate the point of frame switching, it is not very practical. So here is a more likely use case you'll run into -- working with the TinyMCE Editor.

## Another Example

You can find the page we are testing against [here](http://the-internet.herokuapp.com/tinymce).

```ruby
# Iframes
run {
  @driver.get 'http://the-internet.herokuapp.com/tinymce'
  @driver.switch_to.frame('mce_0_ifr')
    editor = @driver.find_element(id: 'tinymce')
    before_text = editor.text
    editor.clear
    editor.send_keys 'Hello World!'
    after_text = editor.text

  after_text.should_not == before_text
}
```

Once the page renders we switch into the TinyMCE frame. While the frame element does not have a `name` attribute it does have an `id`. This works just the same in the `switch_to.frame` call, so we use it.

Now that Selenium is properly scoped we are able to use the top-level id of the TinyMCE widget to:

+ grab its text
+ clear its text
+ input new text
+ grab the altered text
+ assert that the before and after texts are not the same

Keep in mind that if we need to access a part of the page outside of the frame we are currently in, then we will need to switch to it. For instance...

```ruby
@driver.switch_to.default_content
@driver.find_element(css: 'h3').text.should_not == ""
```

This switches us back to the main page and enables us to assert that the heading on the page is there.

## Expected Behavior

+ Load the page
+ Switch to the frame you want
+ Find and take an action against an element
+ Switch to another frame or the main document if need-be
+ Assert that the desired outcome has occurred
