# Tables

Odds are at some point you've come across the use of tables in a web application to display data or information to a user, enabling them to sort and manipulate it. Depending on your application it can be quite common and something you will want to write automation for.

But when that table has no helpful markup (e.g., `id` or `class` attributes) it quickly becomes more difficult to work with and write tests against. And if you're able to pull something together, it will likely not work against older browsers.

All hope is not lost because you can traverse the table through the use of CSS Pseudo-classes.

But keep in mind that if you care about older browsers, then this approach won't work on them. In those cases it's better to get something working in the short term and file a fix with your front-end developer(s) to update the table with helpful attributes.

## A Tables & CSS Pseudo-classes Primer

Understanding the broad strokes of an HTML table's structure goes a long way in writing effective automation against it. So here's a quick primer.

A table has...

+ a header (e.g., `<thead>`)
+ a body (e.g., `<tbody>`).
+ rows (e.g., `<tr>`) -- horizontal slats of data
+ columns -- vertical slats of data

Columns are made up of cells which are represented as...

+ `<th>` in a header
+ `<td>` in a body (also known as __table data__)

CSS Pseudo-classes work by walking through the structure of an object and targeting a specific part of it based on a relative number (e.g., the __third__ `<td>` cell from a row in the table body). This works well with tables since we can couple it with Selenium to grab all instances of a target (e.g., the third `<td>` cell from __all rows__ in the table body) -- which gives us all of the data for a specific column.

Let's dig in with an example for a common set of table functionality -- sorting columns in ascending and descending order.

## An Example

__NOTE: You can see the application under test [here](http://the-internet.herokuapp.com/tables). There are 2 tables. We will start with Example 1 and then work with Example 2__

We kick things off by requiring our dependent libraries (`selenium-webriver` to drive the browser and `rspec-expectations` to handle our assertions) and wiring up our `setup`, `teardown`, and `run` actions.

```ruby
require 'selenium-webdriver'
require 'rspec-expectations'

def setup
  @driver = Selenium::WebDriver.for :firefox
end

def teardown
  @driver.quit
end

def run
  setup
  yield
  teardown
end

```

Here is a snippet from the first table we are working with. Note that it does not have any `id` or `class` attributes.

```html
<table id="table1" class="tablesorter">
    <thead>
      <tr>
        <th><span>Last Name</span></th>
        <th><span>First Name</span></th>
        <th><span>Email</span></th>
        <th><span>Due</span></th>
        <th><span>Web Site</span></th>
        <th><span>Action</span></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Smith</td>
        <td>John</td>
        <td>jsmith@gmail.com</td>
        <td>$50.00</td>
        <td>http://www.jsmith.com</td>
        <td>
          <a href='#edit'>edit</a>
          <a href='#delete'>delete</a>
        </td>
      </tr>
```

There are 6 columns (`Last Name`, `First Name`, `Email`, `Due`, `Web Site`, and `Action`). Each one is sortable. The first click should sort them in ascending order, the second click in descending order.

And there is a small sampling of data in the table to work with (4 rows worth), so we should be able to sort and confirm that it actually worked. So let's do that -- starting with the `Due` column.

```ruby
run do
  @driver.get 'http://the-internet.herokuapp.com/tables'

  @driver.find_element(css: '#table1 thead tr th:nth-of-type(4)').click

  dues = @driver.find_elements(css: '#table1 tbody tr td:nth-of-type(4)')
  due_values = []
  dues.each { |due| due_values << due.text.gsub(/\$/,'').to_f }

  (due_values == due_values.sort).should == true
```

After navigating to the page we find and click the column heading that we want with a CSS Pseudo-class (e.g., `#table1 thead tr th:nth-of-type(4)`) which is effectively saying 'give me the 4th `th` element in the table heading' which is the placement of `Due`.

We then use another pseudo-class to find all of the `td` elements found within each row of the table body that are `Due`s -- which is effectively the 4th column.

Once we have them we create an array and iterate over the collection of `td` elements we found, stripping off the dollar sign, converting them into a decimal number, and shoveling them into the array. With this array of numbers we can then compare it against a sorted version of itself to make sure that they match. If they do then the table data on the page was sorted in ascending order.

If we click the `Due` heading again it should sort in descending order. The code for that is identical except for the assertion which is checking the same thing but seeing if it's false.

```ruby
  @driver.find_element(css: '#table1 thead tr th:nth-of-type(4)').click

  dues = @driver.find_elements(css: '#table1 tbody tr td:nth-of-type(4)')
  due_values = []
  dues.each { |due| due_values << due.text.gsub(/\$/,'').to_i }

  (due_values == due_values.sort).should == false
```

We can then expand our sort check to a different column and see that it gets sorted correctly. So let's focus on the `Email` column.

```ruby
  @driver.find_element(css: '#table1 thead tr th:nth-of-type(3)').click

  emails = @driver.find_elements(css: '#table1 tbody tr td:nth-of-type(3)')
  email_values = []
  emails.each { |email| email_values << email.text }

  (email_values == email_values.sort).should == true
end
```

The mechanism for this is the same except that we are not manipulating the text before checking it. We are just doing a straight comparision. This is because Ruby will sort a collection of numbers that are represented as strings in descending order. Whereas all other comparisons will sort in ascending order.

## But What About Older Browsers?

So, now we have a working example that will load the page and check sorting three different ways. Great! But as soon as we run this againt an older browser (like Internet Explorer 8) it will throw an exception stating `Unable to find element`. This is because older browsers don't support CSS Pseudo-classes.

You've already come a long way, so it's best to get value out of what you've just written. You can run these tests on current browsers, file a fix with your front-end developers to improve the table design with some `class` attributes, and then update these tests once they've made the necessary changes.

Here is a snippet of what our original table would look like with helpful attributes added in.

```html
<table id="table2" class="tablesorter">
    <thead>
      <tr>
        <th><span class='last-name'>Last Name</span></th>
        <th><span class='first-name'>First Name</span></th>
        <th><span class='email'>Email</span></th>
        <th><span class='dues'>Due</span></th>
        <th><span class='web-site'>Web Site</span></th>
        <th><span class='action'>Action</span></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class='last-name'>Smith</td>
        <td class='first-name'>John</td>
        <td class='email'>jsmith@gmail.com</td>
        <td class='dues'>$50.00</td>
        <td class='web-site'>http://www.jsmith.com</td>
        <td class='action'>
          <a href='#edit'>edit</a>
          <a href='#delete'>delete</a>
        </td>
      </tr>
```

With that, the selectors for our sorting tests become a lot simpler and more expressive. Here's an example of the `Due` ascending test being written against it.

```ruby
run do
  @driver.get 'http://the-internet.herokuapp.com/tables'
  @driver.find_element(css: '#table2 thead .dues').click
  dues = @driver.find_elements(css: '#table2 tbody .dues')
  due_values = []
  dues.each { |due| due_values << due.text.gsub(/\$/,'').to_f }
  (due_values == due_values.sort).should == true
end
```

Not only will these selectors work in both current and older browsers, but they are more resilient to changes in the table column order since they're not hard-coded values any more.

## Expected Behavior

+ Load the page
+ Click the column heading
+ Grab the values for that column
+ Assert that they are sorted in the correct order (ascending or descending)

## Outro

CSS Pseudo-classes are a great resource and unlock a lot of potential for your tests -- enabling a bit of CSS gymnastics (assuming you've come up with an automation strategy that rules out older browsers).

For more info on CSS Pseudo-classes you should check out [a nice write-up by Sauce Labs](http://sauceio.com/index.php/2010/01/selenium-totw-css-selectors-in-selenium-demystified/). And maybe [the W3C spec](http://www.w3.org/TR/css3-selectors/#structural-pseudos), but that may be a bit more of a rabbit hole than you may want to fall down.

And for a more in-depth walk-through on HTML Table design you can check out [Treehouse's write-up](http://blog.teamtreehouse.com/how-to-code-sortable-tabular-data-with-jquery).
