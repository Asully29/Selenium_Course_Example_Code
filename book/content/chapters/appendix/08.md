# HTTP Status Codes

There are times when you are testing a page (or numerous pages) and you want to verify that it responded correctly. A great way to handle this is by checking the HTTP Status Code that the browser received. But this functionality is not available in Selenium WebDriver.

But fear not because there is more than one way to fall down this deep rabbit hole.

The tried and true approach that Selenium Committers and Practitioners recommend is to use a proxy server. With it, we will be able to watch and manipulate network traffic between our tests and the application under test -- giving us access to a whole host of functionality that we wouldn't have otherwise had.

Let's step through an example using [BrowserMob Proxy](http://bmp.lightbody.net/).

## An Example

First we have to download BrowserMob Proxy to our working directory (available on [their website](http://bmp.lightbody.net/)). With that in hand, we are ready to wire up our script.  

At the top of the file we include the libraries we need -- `selenium-webdriver` to drive the browser, `rspec-expectations` for our assertions, and `browsermob/proxy` to use the proxy server. You can find more info on the `browsermob-proxy` gem we are using [here](https://rubygems.org/gems/browsermob-proxy).

```ruby
require 'selenium-webdriver'
require 'rspec-expectations'
require 'browsermob/proxy'
```

Next we create a `configure_proxy` method to prepare the proxy for use with Selenium. In it we start the proxy server and create a configurable instance of it. We then create a browser profile (Firefox in this case) and set it to use the proxy server.  

Once that's done, we wire up the `configure_proxy` method into the setup action, and pass in the profile object to our Selenium instance.  

```ruby
def configure_proxy
  server = BrowserMob::Proxy::Server.new('./browsermob-proxy/bin/browsermob-proxy')
  server.start
  @proxy = server.create_proxy
  @profile = Selenium::WebDriver::Firefox::Profile.new
  @profile.proxy = @proxy.selenium_proxy
end

def setup
  configure_proxy
  @driver = Selenium::WebDriver.for :firefox, :profile => @profile
end
```

After that, we wire up our teardown and run actions.  

```ruby
def teardown
  @driver.quit
  @proxy.close
end

def run
  setup
  yield
  teardown
end
```

And to make things clean we wrap up our proxy calls to get the status code from the [HTTP Archive](http://www.softwareishard.com/blog/har-12-spec/) (a.k.a. HAR) in a `visit` action that returns it after it visits the page.  

```ruby
def visit(url)
  @proxy.new_har
  @driver.get url
  @proxy.har.entries.first.response.status
end
```

All that's left is our run action, which is simple and to the point.  

```ruby
run do
  status_code = visit 'http://the-internet.herokuapp.com/status_codes/404'
  status_code.should == 404
end
```

## Expected Behavior

+ Visit the URL
+ Retrieve the HTTP Status Code
+ Assert that it is the correct status code

## Outro

This was inspired by [Jim Evans](https://twitter.com/jimevansmusic)' multi-part blog post series on doing the same thing in C# with Fiddler ([1](http://jimevansmusic.blogspot.com/2013/08/implementing-webdriver-http-status.html), [2](http://jimevansmusic.blogspot.com/2013/08/implementing-http-status-codes-in.html), [3](http://jimevansmusic.blogspot.com/2013/08/implementing-http-status-codes-in_17.html)) which was in response to [Selenium Issue 141](https://code.google.com/p/selenium/issues/detail?id=141). Thanks Jim!
