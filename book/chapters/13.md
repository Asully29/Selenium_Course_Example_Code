# Running Browsers In The Cloud

If you've ever needed to test features in an older browser like Internet Explorer 8 then odds are you ran a virtual machine (VM) on your computer with a "legit" version of Windows XP.

Handy, but what happens when you need to check things on multiple versions of IE? Now you're looking at multiple VMs. And what about when you need to scale and cover other browser and Operating System (OS) combinations? Now you're looking at provisioning, running, and maintaining your own farm of machines and standing up something like Selenium Grid to coordinate tests across them.

And all you wanted to do was run your tests on the browsers you cared about...

Rather than take on the overhead of a test infrastructure you can easily outsource things to a third-party cloud provider. There are a handful of players in this space, but there's one that stands out -- Sauce Labs.

## Why Sauce Labs?

They don't stand out because they enable you to run your tests on pretty much every browser/OS/platform combination. Or because they have great test reporting (like screenshots AND video recordings of your tests). Or for any of the other [killer features they have](https://saucelabs.com/features).

They stand out because they're not just building something to sell. They work hard to help make the Selenium Community (and open source software) better. And it's through their contributions that they are able to discern what to build -- so it's something that is attuned to the needs of the community.

## A Selenium Remote, Selenium Grid, And Sauce Labs Primer

At the heart of Selenium at scale is the use of Selenium Grid and Selenium Remote. Selenium Grid lets you distribute test execution across several machines and you connect to it with Selenium Remote -- specifying the browser type and version through the use of Selenium Remote's `Capabilities`.

This is fundamentally how Sauce Labs works. Behind the curtain they are ultimately running Selenium Grid, and they receive and execute your tests through Selenium Remote -- knowing which browser and operating system to use because of the `Capabilities` it's users specify.

Let's dig in with an example.

## An Example

### Part 1: Initial Setup

__NOTE: You'll need an account to use Sauce Labs. Their free one offers enough to get you started. And if you're signing up because you want to test an open source project, then be sure to give [their 'Open Sauce' account](https://saucelabs.com/opensauce) a look (tl;dr -- it's completely free).__

With Sauce Labs we need to provide specifics about what we want in our test environment, our credentials, and configure Selenium a little bit differently than we have been. Let's start by creating a new config file for cloud execution ('config_cloud.rb').

```ruby
# filename: config_cloud.rb

ENV['base_url']         ||= 'http://the-internet.herokuapp.com'
ENV['host']             = 'saucelabs'
ENV['operating_system'] ||= 'Windows XP'
ENV['browser']          ||= 'internet_explorer'
ENV['browser_version']  ||= '8'
ENV['SAUCE_USERNAME']   = 'your-sauce-username'
ENV['SAUCE_ACCESS_KEY'] = 'your-sauce-access-key'
```

Notice the use of a host environment variable. This is what we'll use in our `spec_helper` file to determine whether to run things locally or in the cloud. And we'll use the other environment variables to populate the `Capabilities`.

```ruby
# filename: spec/spec_helper.rb

require 'selenium-webdriver'

RSpec.configure do |config|

  config.before(:each) do
    case ENV['host']
    when 'saucelabs'
      caps = Selenium::WebDriver::Remote::Capabilities.send(ENV['browser'])
      caps.version = ENV['browser_version']
      caps.platform = ENV['operating_system']
      caps[:name] = example.metadata[:full_description]

      @driver = Selenium::WebDriver.for(
        :remote,
        url: "http://#{ENV['SAUCE_USERNAME']}:#{ENV['SAUCE_ACCESS_KEY']}@ondemand.saucelabs.com:80/wd/hub",
        desired_capabilities: caps)
    else
      case ENV['browser']
      when 'firefox'
        @driver = Selenium::WebDriver.for :firefox
      when 'chrome'
        Selenium::WebDriver::Chrome::Service.executable_path = File.join(Dir.pwd, 'vendor/chromedriver')
        @driver = Selenium::WebDriver.for :chrome
      end
    end
  end

  config.after(:each) do
    @driver.quit
  end

end
```

We've taken our original conditional and made it nested underneath a check for the host environment variable. If the host is set to 'saucelabs', then we configure the capabilities for Selenium Remote, passing in the requisite information that we will need for our Sauce Labs session. Otherwise, it will run our tests locally.

The actual username and API key have been omitted from this example. To make this work, simply add yours in to the 'config_cloud.rb' file.

There are a few things in this example that may be worth elaborating on.

First, we are using something called metaprogramming (a.k.a. code that writes code) when we are calling `Selenium::WebDriver::Remote::Capabilities`. We are using the `.send` method to pass in the environment variable. The value of which, in this case, is the same name as the method to configure Selenium Remote to use Internet Explorer. So, we are in effect, creating `Selenium::WebDriver::Remote::Capabilitites.internet_explorer`. And if we were to specify 'chrome' for `ENV['browser']`, then it would give us `Selenium::WebDriver::Remote::Capabilities.chrome`.

Second, for `caps[:name]` we are using a piece of functionality built into RSpec which gives us the name of each test as it is being run. This will make it so each individual job in Sauce Labs will have the name of the test that was run.

Third, for the `url:` line in our `@driver` instantiation, we are injecting our environment variable through the use of string interpolation. This is why we are using double-quoted strings. If they were single-quotes then we wouldn't be able to do it.

Now if we run our test suite (`rspec -r ./config_cloud.rb`) and navigate to [our Sauce Labs Account page](https://saucelabs.com/account) then we should see each of the tests running in their own job, with proper names, against Internet Explorer 8.

### Part 2: Test Status

The only thing missing now is the pass/fail status of the job. In our local terminal window everything should be coming up green. But in the list of our Sauce jobs, the 'Results' panel for everything will just say 'Finished'. This will make our results less useful in the long run, so let's fix it.

Thanks to Sauce Labs' 'sauce_whisk' gem, it's really simple to do.

After we install it we will need to require it somewhere, and our 'config_cloud.rb' file seems like a logical place, since we will only need it when running our tests in Sauce. So let's add it to the top of the file.

```ruby
# filename: config_cloud.rb

require 'sauce_whisk'
...
```

All that's left is to add an action to our `after(:each)` block in our 'spec_helper' file.

Before we issue `@driver.quit` we will want to grab the job ID from our `@driver` object and set the job status based on the test result. Also, we'll want to make sure that it only executes when running tests against Sauce Labs -- so we'll want to wrap it in a conditional check against the host environment variable.

```ruby
# filename: spec/spec_helper.rb
require 'selenium-webdriver'

RSpec.configure do |config|
  ...

  config.after(:each) do
    if ENV['host'] == 'saucelabs'
      if example.exception.nil?
        SauceWhisk::Jobs.pass_job @driver.session_id
      else
        SauceWhisk::Jobs.fail_job @driver.session_id
      end
    end

    @driver.quit
  end

end
```

Now when we run our tests (`rspec -r ./config_cloud.rb`) and navigate to [our Sauce Labs Account page](https://saucelabs.com/account), we should see our tests running like before -- but now when they finish there should be a proper test status (e.g., 'Pass' or 'Fail').

### Part 3: Accessing Private Apps

There are various ways that companies make their pre-production application available for testing. Some use an obscure public URL and protect it with some form of authentication (e.g., Basic Auth, or cert based authentication). Others keep it behind their firewall.

For those that stay behind a firewall, Sauce Labs has got you covered. They have a program called [Sauce Connect](https://saucelabs.com/docs/connect) that creates a secure tunnel between your machine and their cloud. With it, you can run tests in Sauce Labs and still have them reach the apps that are only available on your network.

In Ruby there are two ways to leverage Sauce Connect; a separate download, or through another one of Sauce's Ruby libraries -- 'sauce-connect'.

Let's step through an example using the 'sauce-connect' gem and running a copy of 'the-internet' locally.

## An Example

First we'll need to install the 'sauce-connect' library. Once we have it, we'll want to add it to our 'config_cloud.rb' file. But since the Sauce Connect tunnel will automatically load when we require the library, we will want to wrap the require statement in a conditional. And to require it we will need to refer to it as `sauce`.

```ruby
# filename: config_cloud.rb

require 'sauce_whisk'

ENV['base_url']         ||= 'http://the-internet.herokuapp.com'
ENV['host']             = 'saucelabs'
ENV['operating_system'] ||= 'Windows XP'
ENV['browser']          ||= 'internet_explorer'
ENV['browser_version']  ||= '8'
ENV['SAUCE_USERNAME']   = 'your-sauce-username'
ENV['SAUCE_ACCESS_KEY'] = 'your-sauce-access-key'
ENV['tunnel']           ||= ''

unless ENV['tunnel'].empty?
  require 'sauce'
  ENV['base_url']       = 'http://the-internet-local:4567'
end
```

At the bottom of the file we've added a new environment variable (`ENV['tunnel']`), set it to an empty string, and made it so we can override it at runtime.

We then check to see if it's empty. If it is empty, then we do nothing. If it isn't empty, then we load the sauce-connect library (`require 'sauce'`) and change the base URL to run our tests against a different end-point (`'http://the-internet-local:4567'`).

This new URL is how we will interact with our local copy of 'the-internet'. To use it, we'll first need to download and unzip a copy of it from [it's GitHub repo](https://github.com/tourdedave/the-internet) and place it in 'vendor/the-internet'.

When we're done, our directory tree should look like this:

```sh
.
|-- config_cloud.rb
|-- config.rb
|-- pages
|   |-- base_page.rb
|   |-- dynamic_loading.rb
|   `-- login.rb
|-- sauce_connect.log
|-- spec
|   |-- dynamic_loading_spec.rb
|   |-- login_spec.rb
|   `-- spec_helper.rb
`-- vendor
    |-- chromedriver
    `-- the-internet
```

Next we need to update our local hosts file to map our local IP address (127.0.0.1) to a DNS helper name (e.g., 'the-internet-local'). This is so our tests running on Sauce Labs will be able to find our local server.

If we just provide 'localhost' or 127.0.0.1, it won't work (as noted in [this Sauce Support post](http://support.saucelabs.com/entries/20912606-Localhost-ports-for-Sauce-Connect). Updating the hosts file varies depending on your operating system. So if you're not sure how to do it, or what that means, then give [this How-To Geek article](http://www.howtogeek.com/howto/27350/) a read.

Now we can open a new terminal window, change into the 'vendor/the-internet' directory, and start the app (with `ruby server.rb`) -- which will make it available on port 4567. If you receive an error, be sure to install the necessary gems (e.g., try running `bundle install` before trying the server again).

Now that our server is running locally, let's switch back over to our original terminal window and run our tests. In order to trigger our tunnel, we will need to override our tunnel environment variable. So let's run the following: `tunnel='on' rspec -r ./config_cloud.rb`.

We should then see the following appear in our terminal.

```sh
[Connecting to Sauce Labs...]
```

If we navigate to [our Sauce Labs Tunnel Status page](https://saucelabs.com/tunnels) then we should see a tunnel listed as active. And if we navigate to [our Sauce Labs Account page](https://saucelabs.com/account) then we should see each of the tests running in their own job -- each executing against our local server.

Once the tests finish, the tunnel should close. We can quickly confirm this by revisiting [the Sauce Labs Tunnel Status page](https://saucelabs.com/tunnels).

### Part 4: A Small Bit Of Clean-up

One by-product of this setup is that a 'sauce_connect.log' file will get outputted into our root directory. We won't really end up using it, nor is it easily configurable to suppress or move it to a different location. Therefore we can choose to ignore it by adding it to a version control system ignore file (which is '.gitignore' in my case) so that it doesn't get pushed up into the test repository.

```ruby
# filename: .gitignore

*.log
```

Now that we have two config files, let's move them into their own directory and pare down the names for simplicity. Let's create a `config` directory and rename the files to `local.rb` and `cloud.rb`.

This leaves our directory tree structure looking like this:

```sh
.
|-- config
|   |-- cloud.rb
|   `-- local.rb
|-- pages
|   |-- base_page.rb
|   |-- dynamic_loading.rb
|   `-- login.rb
|-- spec
|   |-- dynamic_loading_spec.rb
|   |-- login_spec.rb
|   `-- spec_helper.rb
`-- vendor
    |-- chromedriver
    `-- the-internet
```
