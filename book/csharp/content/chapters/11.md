# Prepping For Use

Now that we have some tests and page objects, we'll want to start thinking about how to structure our test code to be more flexible. That way it can scale to meet our needs.

## Part 1: Global Setup & Teardown

We'll start by pulling the Selenium setup and teardown out of our tests and into a central location.

Similar to our base page object, we'll want to create a base test. So let's create a new file called `BaseTest.cs` in the `Tests` directory.

```text
├── PageObjects
│   ├── BasePage.cs
│   ├── DynamicLoadingPage.cs
│   └── LoginPage.cs
├── Tests
│   ├── BaseTest.cs
│   ├── DynamicLoadingTest.cs
│   └── LoginTest.cs
└── Vendor
    └── geckodriver.exe
```

And here are the contents of the file.

```csharp
// filename: Tests/BaseTest.cs
using OpenQA.Selenium;
using NUnit.Framework;
using OpenQA.Selenium.Firefox;

namespace Tests
{
    [TestFixture]
    class BaseTest
    {
        private static string VendorDirectory = System.IO.Directory.GetParent(
            System.AppContext.BaseDirectory).
            Parent.Parent.Parent.FullName
            + @"/vendor";
        protected IWebDriver Driver;

        [SetUp]
        protected void SetUp()
        {
            var Service = FirefoxDriverService.CreateDefaultService(VendorDirectory);
            Driver = new FirefoxDriver(Service);
        }

        [TearDown]
        protected void TearDown()
        {
            Driver.Quit();
        }
    }
}
```

After importing a few necessary classes we specify the `BaseTest` class and wire up some methods that will take care of setting up and tearing down Selenium before and after each test.

Now let's update our tests to establish inheritance with this base test class, remove the Selenium setup/teardown actions, and remove the unnecessary `using` statements. When we're done our test files should look like this:

```csharp
// filename: Tests/LoginTest.cs
using NUnit.Framework;
using PageObjects;

namespace Tests
{
    [TestFixture]
    class LoginTest : BaseTest
    {
        LoginPage Login;

        [SetUp]
        public new void SetUp()
        {
            Login = new LoginPage(Driver);
        }

        [Test]
        public void ValidAccount()
        {
            Login.With("tomsmith", "SuperSecretPassword!");
            Assert.That(Login.SuccessMessagePresent);
        }

        [Test]
        public void BadPasswordProvided()
        {
            Login.With("tomsmith", "bad password");
            Assert.That(Login.FailureMessagePresent);
        }
    }
}
```

```csharp
// filename: Tests/DynamicLoadingTest.cs
using NUnit.Framework;
using PageObjects;

namespace Tests
{
    [TestFixture]
    class DynamicLoadingTest : BaseTest
    {
        DynamicLoadingPage DynamicLoading;

        [SetUp]
        public new void SetUp()
        {
            DynamicLoading = new DynamicLoadingPage(Driver);
        }

        [Test]
        public void ElementHidden()
        {
            DynamicLoading.LoadExample(1);
            Assert.That(DynamicLoading.FinishTextPresent);
        }

        [Test]
        public void ElementRendered()
        {
            DynamicLoading.LoadExample(2);
            Assert.That(DynamicLoading.FinishTextPresent);
        }
    }
}
```

## Part 2: Base URL

It's a given that we'll need to run our tests against different environments (e.g., local, test, staging, production, etc.). So let's make it so we can specify a different base URL for our tests at runtime.

We can do this by leveraging an environment variable and updating our `BaseTest` to receive it or set a sensible default if one isn't provided.

```csharp
// filename: Tests/BaseTest.cs
// ...
    class BaseTest
    {
        private static string VendorDirectory = System.IO.Directory.GetParent(
            System.AppContext.BaseDirectory).
            Parent.Parent.Parent.FullName
            + @"/vendor";
        protected IWebDriver Driver;
        public static string BaseUrl;

        [SetUp]
        protected void SetUp()
        {
            BaseUrl     = System.Environment.GetEnvironmentVariable("BASE_URL") ?? "http://the-internet.herokuapp.com";
// ...
```

By using `System.Environment.GetEnvironmentVariable` we are able to access environment variables by their name, which we do for `BASE_URL`, storing it in a public variable of `BaseUrl`. If no value is provided, we default to the publicly available end-point of `the-internet`.

Now to use the `BaseUrl` in our page objects.

```csharp
// filename: PageObjects/BasePage.cs
// ...
        protected void Visit(string url)
        {
            if (url.StartsWith("http"))
            {
                Driver.Navigate().GoToUrl(url);
            } else
            {
                Driver.Navigate().GoToUrl(Tests.BaseTest.BaseUrl + url);
            }
        }
// ...
```

In `Visit` there could be a case where we'll want to navigate to a full URL so to be safe we've added a conditional check of the `url` parameter to see if a full URL was passed in. If so, we'll visit it. If not, the `BaseUrl` will be combined with the URL path that was passed in to `url` to create a full URL.

Now all we need to do is update our page objects so they're no longer using hard-coded URLs when calling `Visit`.

```csharp
// filename: PageObjects/LoginPage.cs
// ...
        public LoginPage(IWebDriver driver)
        {
            Visit("/login");
            Assert.That(IsDisplayed(LoginForm));
        }
// ...
```

```csharp
// filename: PageObjects/DynamicLoadingPage.cs
// ...
        public void LoadExample(int exampleNumber)
        {
            Visit("/dynamic_loading/" + exampleNumber);
            Click(StartButton);
        }
// ...
```

## Outro

Now when running our tests, we can specify a different base URL by specifying a `BASE_URL` either on our machine or when running our tests from the command-line (e.g., `BASE_URL=http://your-new-url dotnet test`). We're also in a better position now with our setup and teardown abstracted into a central location. Now we can easily extend our test framework to run our tests on other browsers.


