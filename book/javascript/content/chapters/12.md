# Prepping For Use

Now that we have some tests and page objects, we'll want to start thinking about how to structure our test code to be more flexible. That way it can scale to meet our needs.

## Part 1: Global Setup & Teardown

We'll start by pulling the Selenium setup and teardown out of our tests and into a central location.

We'll create three things. A class that will contain the creation and destruction of our Selenium instances (a.k.a. a Driver Factory), a helper that all tests will pull from, and an option file Mocha uses to store commonly used command-line arguments.

In the `lib` directory we'll create a new file called `DriverFactory.js`, and in the `test` directory we'll create files called `spec_helper.js` and `mocha.opts`.

```text
├── lib
│   └── DriverFactory.js
├── package.json
├── pages
│   ├── BasePage.js
│   ├── DynamicLoadingPage.js
│   └── LoginPage.js
├── test
│   ├── DynamicLoadingTest.js
│   ├── LoginTest.js
│   ├── mocha.opts
│   └── spec_helper.js
└── vendor
    └── geckodriver
```

Here are the initial contents of the Driver Factory.

```javascript
// filename: lib/DriverFactory.js
const path = require('path')
const { Builder } = require('selenium-webdriver')
const { Eyes } = require('@applitools/eyes-selenium')

class DriverFactory {
  async _openEyes() {
    this.eyes = new Eyes()
    this.eyes.setApiKey(process.env.APPLITOOLS_API_KEY)
    return await this.eyes.open(this.driver, 'the-internet', this.testName, {
      width: 1024,
      height: 768,
    })
  }

  async build(testName, hasEyesCommands = false) {
    this.testName = testName
    process.env.PATH += path.delimiter + path.join(__dirname, '..', 'vendor')
    this.driver = await new Builder().forBrowser('firefox').build()
    if (hasEyesCommands) this.driver = await this._openEyes()
    return this.driver
  }

  async quit() {
    await this.driver.quit()
    if (this.eyes) await this.eyes.abortIfNotClosed()
  }
}

module.exports = DriverFactory
```

After requiring our requisite libraries, we declare a class along with three methods -- `_openEyes`, `build`, and `quit`.

__NOTE: In JavaScript, an underscore prefix in a variable or method name is used to denote that something is meant to be private (e.g., `_openEyes`). It's not meant to be used outside of the class.__

`build` is responsible for creating an instance of Selenium. `_openEyes` is responsible for creating an instance of Eyes for visual testing. `quit` is responsible for destroying the Selenium instance and terminating the Eye session if it was started and not properly closed.

The class ends with `module.exports`, just like in previous classes we've created.

Now to update our `mocha.opts` file. It's a small change that will help us clean up the hard-coded timeout that we've needed to specify in each test.

```javascript
// filename: test/mocha.opts
-t 60000
```

Now let's put everything to use in our spec helper.

```javascript
// filename: test/spec_helper.js
const DriverFactory = require('../lib/DriverFactory')
const driverFactory = new DriverFactory()

beforeEach(async function() {
  const testName = this.currentTest.fullTitle()
  const hasEyesCommands = this.currentTest.body.match(/this.eyes/)
  this.driver = await driverFactory.build(testName, hasEyesCommands)
  this.eyes = driverFactory.eyes
})

afterEach(async function() {
  await driverFactory.quit()
})
```

In Mocha, when you specify before and after hooks outside of a test class they are used globally for all tests. These are referred to as root-level hooks. 

At the top of the spec helper we require the Driver Factory and create a new instance of it, storing it in a variable. 

In `beforeEach` we grab the name of the currently running test, check whether or not there are any visual testing commands using Applitools Eyes, and then we create a driver instance and store it in a variable on `this` (which will make it accessible to the test). We also store an instance of Eyes on `this`.

In `afterEach` we call the `quit` method in the Driver Factory to destroy the Selenium instance and abort any lingering Eyes sessions (if they exist).

Now to update our tests.

```javascript
// filename: test/LoginTest.js
require('./spec_helper')
const assert = require('assert')
const LoginPage = require('../pages/LoginPage')

describe('Login', function() {
  let login

  beforeEach(async function() {
    login = new LoginPage(this.driver)
    await login.load()
  })

  it('with valid credentials', async function() {
    await login.authenticate('tomsmith', 'SuperSecretPassword!')
    assert(await login.successMessagePresent(), 'Success message not displayed')
    await this.eyes.checkWindow('Logged in')
    await this.eyes.close()
  })

  it('with invalid credentials', async function() {
    await login.authenticate('tomsmith', 'bad password')
    assert(await login.failureMessagePresent(), 'Failure message not displayed')
  })
})

```

```javascript
// filename: test/DynamicLoadingTest.js
require('./spec_helper')
const assert = require('assert')
const DynamicLoadingPage = require('../pages/DynamicLoadingPage')

describe('Dynamic Loading', function() {
  let dynamicLoading

  beforeEach(async function() {
    dynamicLoading = new DynamicLoadingPage(this.driver)
  })

  it('hidden element', async function() {
    await dynamicLoading.loadExample('1')
    assert(
      await dynamicLoading.isFinishTextPresent(),
      true,
      'Finish text not displayed'
    )
  })

  it('rendered element', async function() {
    await dynamicLoading.loadExample('2')
    assert(
      await dynamicLoading.isFinishTextPresent(),
      true,
      'Finish text not displayed'
    )
  })
})
```

In order to use the spec helper we just need to require it.

Then we're able to remove the creation and storing of a driver instance in `beforeEach` and leverage the driver variable stored on `this` instead. We're also able to remove the `afterEach` method entirely.

If we save our files and run our tests (e.g., `mocha` from the command-line) they should work just like before.

## Part 2: Base URL

It's a given that we'll need to run our tests against different environments (e.g., localhost, test, staging, production, etc.). So let's make it so we can specify a different base URL for our tests at runtime.

First, let's create a file called `config.js` in the `lib` directory.

```text
├── lib
│   ├── config.js
│   └── DriverFactory.js
├── package.json
├── pages
│   ├── BasePage.js
│   ├── DynamicLoadingPage.js
│   └── LoginPage.js
├── test
│   ├── DynamicLoadingTest.js
│   ├── LoginTest.js
│   ├── mocha.opts
│   └── spec_helper.js
└── vendor
    └── geckodriver
```

In it we'll specify a variable for `baseUrl` that will grab and store an environment. If one is not provided then a sensible default will be used.

```javascript
// filename: lib/config.js
module.exports = {
  baseUrl: process.env.BASE_URL || 'http://the-internet.herokuapp.com'
};
```

Now let's update the visit method in the base page object to use this config object.

```javascript
// filename: pages/BasePage.js
const config = require('./config')
// ...
async function visit(url) {
  if (url.startsWith('http')) {
    await this.driver.get(url)
  } else {
    await this.driver.get(config.baseUrl + url)
  }
}

```

In `visit` there could be a case where we'll want to navigate to a full URL so to be safe we've added a conditional check of the `url` parameter to see if a full URL was passed in. If so, we visit it. If not, `config.baseUrl` is combined with the URL path passed in as an argument to create the full URL (e.g., `config.baseUrl + url`) and visit it.

Now all we need to do is update our page objects so they're no longer using hard-coded URLs.

```javascript
// filename: pages/LoginPage.js
// ...
  async load() {
    await this.visit('/login')
    if (!(await this.isDisplayed(LOGIN_FORM, 1000)))
      throw new Error('Login form not loaded')
  }
// ...
```

```javascript
// filename: pages/DynamicLoadingPage.js
// ...
  async loadExample(exampleNumber) {
    await this.visit('/dynamic_loading/' + exampleNumber)
    await this.click(START_BUTTON)
  }
// ...
```

## Step 3: Viewport Size

When running tests with visual validations we'll eventually want to specify different viewport sizes. Right now this value is hard-coded in our setup code. We can move it to our config file, and make it so the sensible defaults can be overridden at run-time if needbe.

```javascript
// filename: lib/config.js
module.exports = {
  baseUrl: process.env.BASE_URL || 'http://the-internet.herokuapp.com',
  viewportWidth: Math.floor(process.env.VIEWPORT_WIDTH) || 1024,
  viewportHeight: Math.floor(process.env.VIEWPORT_HEIGHT) || 768,
}
```

Now to update our DriverFactory to receive and use the config.

```javascript
// filename: lib/DriverFactory.js
// ...
class DriverFactory {
  constructor(config) {
    this.config = config
  }

  async _openEyes() {
    this.eyes = new Eyes()
    this.eyes.setApiKey(process.env.APPLITOOLS_API_KEY)
    return await this.eyes.open(
      this.driver,
      'the-internet',
      this.testName,
      {
        width: this.config.viewportWidth,
        height: this.config.viewportHeight,
      }
    )
  }
// ...
```

```javascript
// filename: test/spec_helper.js
const DriverFactory = require('../lib/DriverFactory')
const config = require('../lib/config')
const driverFactory = new DriverFactory(config)
// ...
```

We made it so the DriverFactory can take a config object as part of instantiation and store it in a class variable. We then updated our spec helper to require the config file and pass it to the DriverFactory. 

## Outro

Now when running our tests, we can specify a different base URL or viewport size by providing some extra information at run-time (e.g., `BASE_URL=url VIEWPORT_HEIGHT=1234 VIEWPORT_WIDTH=567 mocha`). We're also in a better position now with our setup and teardown abstracted into a central location.

Now we can easily extend our test framework to run our tests on other browsers.


