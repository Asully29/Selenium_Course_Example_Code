# Prepping For Use

Now that we have some tests and page objects, we'll want to start thinking about how to structure our test code to be more flexible. That way it can scale to meet our needs.

## Part 1: Global Setup & Teardown

We'll start by pulling the Selenium setup and teardown out of our tests and into a central location.

We'll create three things. A class that will contain the creation and destruction of our Selenium instances (a.k.a. a Driver Factory), a helper that all tests will pull from, and an option file Mocha uses to store commonly used command-line arguments.

In the `lib` directory we'll create a new file called `DriverFactory.js`, and in the `test` directory we'll create files called `spec_helper.js` and `mocha.opts`.

```text
├── lib
│   └── DriverFactory.js
├── package.json
├── pages
│   ├── BasePage.js
│   ├── DynamicLoadingPage.js
│   └── LoginPage.js
├── test
│   ├── DynamicLoadingTest.js
│   ├── LoginTest.js
│   └── spec_helper.js
└── vendor
    └── geckodriver
```

Here are the initial contents of the Driver Factory.

```javascript
// filename: lib/DriverFactory.js
const path = require('path')
const { Builder } = require('selenium-webdriver')
const { Eyes } = require('@applitools/eyes-selenium')

class DriverFactory {
  async _openEyes(testName) {
    this.eyes = new Eyes()
    this.eyes.setApiKey(process.env.APPLITOOLS_API_KEY)
    return await this.eyes.open(this.driver, 'the-internet', testName, {
      width: 1024,
      height: 768,
    })
  }

  async build(testName, hasEyesCommands = false) {
    process.env.PATH += path.delimiter + path.join(__dirname, '..', 'vendor')
    this.driver = await new Builder().forBrowser('firefox').build()
    if (hasEyesCommands) this.driver = await this._openEyes(testName)
    return this.driver
  }

  async quit() {
    await this.driver.quit()
    if (this.eyes) await this.eyes.abortIfNotClosed()
  }
}

module.exports = DriverFactory
```

After requiring our requisite libraries, we declare a class along with three methods -- `_openEyes`, `build`, and `quit`.

__NOTE: In JavaScript, an underscore is used to denote that something is meant to be private (e.g., `_openEyes`). It's not meant to be used outside of the class.__

`build` is responsible for creating an instance of Selenium. `_openEyes` is responsible for creating an instance of Eyes for visual testing. And `quit` is responsible for destroying the Selenium instance (which relies on the `driver` class variable created in `build`).

The class ends with `module.exports`, just like in previous classes we've created.

Now to update our `mocha.opts` file. It's a small change that will help us clean up the hard-coded timeout that we've needed to specify in each test.

```javascript
// filename: test/mocha.opts
-t 60000
```

Now let's put everything to use in our spec helper.

```javascript
// filename: test/spec_helper.js
const DriverFactory = require('../lib/DriverFactory')
const driverFactory = new DriverFactory()

beforeEach(async function() {
  const testName = this.currentTest.fullTitle()
  const hasEyesCommands = this.currentTest.body.match(/this.eyes/)
  this.driver = await driverFactory.build(testName, hasEyesCommands)
  this.eyes = driverFactory.eyes
})

afterEach(async function() {
  await driverFactory.quit()
})
```

In Mocha, when you specify before and after hooks outside of a test class they are used globally for all tests. These are referred to as root-level hooks. 

At the top of the spec helper we require the Driver Factory and create a new instance of it, storing it in a variable. 

In `beforeEach` we grab the name of the currently running test, check whether or not there are any visual testing commands using Applitools Eyes, and then we create a driver instance and store it in a variable on `this` (which will make it accessible to the test). We also store an instance of Eyes on this (if one has been created).

In `afterEach` we call the `quit` method in the Driver Factory, which will destroy the browser instance.

Now to update our tests.

```javascript
// filename: test/LoginTest.js
require('./spec_helper')
const assert = require('assert')
const LoginPage = require('../pages/LoginPage')

describe('Login', function() {
  let login

  beforeEach(async function() {
    login = new LoginPage(this.driver)
    await login.load()
  })

  it('with valid credentials', async function() {
    await login.authenticate('tomsmith', 'SuperSecretPassword!')
    assert(await login.successMessagePresent(), 'Success message not displayed')
    await this.eyes.checkWindow('Logged in')
    await this.eyes.close()
  })

  it('with invalid credentials', async function() {
    await login.authenticate('tomsmith', 'bad password')
    assert(await login.failureMessagePresent(), 'Failure message not displayed')
    await this.eyes.checkWindow('Incomplete Login')
    await this.eyes.close()
  })
})

```

```javascript
// filename: test/DynamicLoadingTest.js
require('./spec_helper')
const assert = require('assert')
const DynamicLoadingPage = require('../pages/DynamicLoadingPage')

describe('Dynamic Loading', function() {
  let dynamicLoading

  beforeEach(async function() {
    dynamicLoading = new DynamicLoadingPage(this.driver)
  })

  it('hidden element', async function() {
    await dynamicLoading.loadExample('1')
    assert(
      await dynamicLoading.isFinishTextPresent(),
      true,
      'Finish text not displayed'
    )
  })

  it('rendered element', async function() {
    await dynamicLoading.loadExample('2')
    assert(
      await dynamicLoading.isFinishTextPresent(),
      true,
      'Finish text not displayed'
    )
  })
})
```

In order to use the spec helper we need to require it. Then we're able to remove the creation and storing of a driver instance in `beforeEach` and leverage the driver variable stored on `this` instead. We're also able to remove the `afterEach` method entirely.

If we save our files and run our tests (e.g., `mocha` from the command-line) they should work just like before.

## Part 2: Base URL

It's a given that we'll need to run our tests against different environments (e.g., local, test, staging, production, etc.). So let's make it so we can specify a different base URL for our tests at runtime.

First, let's create a file called `config.js` in the `lib` directory.

```text
├── lib
│   ├── config.js
│   └── DriverFactory.js
├── package.json
├── pages
│   ├── BasePage.js
│   ├── DynamicLoadingPage.js
│   └── LoginPage.js
├── test
│   ├── DynamicLoadingTest.js
│   ├── LoginTest.js
│   ├── mocha.opts
│   └── spec_helper.js
└── vendor
    └── geckodriver
```

In it we'll specify a variable for `baseUrl` that will grab and store an environment. If one is not provided then a sensible default will be used.

```javascript
// filename: lib/config.js
module.exports = {
  baseUrl: process.env.BASE_URL || 'http://the-internet.herokuapp.com'
};
```

Now let's update the visit method in the base page object to use this config object.

```javascript
// filename: pages/BasePage.js
const config = require('./config')
// ...
async function visit(url) {
  if (url.startsWith('http')) {
    await this.driver.get(url)
  } else {
    await this.driver.get(config.baseUrl + url)
  }
}

```

In `visit` there could be a case where we'll want to navigate to a full URL so to be safe we've added a conditional check of the `url` parameter to see if a full URL was passed in. If so, we visit it. If not, `config.baseUrl` is combined with the URL path passed in as an argument (e.g., `url`) to create the full URL (e.g., `config.baseUrl + url`) and visit it.

Now all we need to do is update our page objects so they're no longer using hard-coded URLs.

```javascript
// filename: pages/LoginPage.js
// ...
  async load() {
    await this.visit('/login')
    if (await !this.isDisplayed(LOGIN_FORM, 1000))
      throw new Error('Login form not loaded')
  }
// ...
```

```javascript
// filename: pages/DynamicLoadingPage.js
// ...
  async loadExample(exampleNumber) {
    await this.visit('/dynamic_loading/' + exampleNumber)
    await this.click(START_BUTTON)
  }
// ...
```

## Outro

Now when running our tests, we can specify a different base URL by providing some extra information at run-time (e.g., `BASE_URL=url mocha`). We're also in a better position now with our setup and teardown abstracted into a central location. Now we can easily extend our test framework to run our tests on other browsers.
