# Running Browsers In The Cloud

If you've ever needed to test features in an older browser like Internet Explorer 9 or 10 then odds are you ran a virtual machine (VM) on your computer with a "legit" version of Windows.

Handy, but what happens when you need to check things on multiple versions of IE? Now you're looking at multiple VMs. And what about when you need cover other browser and Operating System (OS) combinations? Now you're looking at provisioning, running, and maintaining your own set of machines and standing up something like Selenium Grid to coordinate tests across them.

Rather than take on the overhead of a test infrastructure you can easily outsource this to a third-party cloud provider like [Sauce Labs](https://saucelabs.com/).

## A Selenium Grid Primer

At the heart of Selenium at scale is the use of Selenium Grid.

Selenium Grid lets you distribute test execution across several machines and you connect to it with Selenium. You tell the Grid which browser and OS you want your test to run on through the use of Selenium's `DesiredCapabilities`.

Under the hood this is how Sauce Labs works. They are ultimately running Selenium Grid behind the scenes, and they receive and execute tests through Selenium Remote and the `DesiredCapabilities` you set.

Let's dig in with an example.

## An Example

### Part 1: Initial Setup

__NOTE: You'll need an account to use Sauce Labs. Their [free trial](https://saucelabs.com/signup/trial) offers enough to get you started. And if you're signing up because you want to test an open source project, then be sure to check out their [Open Sauce account](https://saucelabs.com/open-source).__

With Sauce Labs we need to provide specifics about what we want in our test environment, our credentials, and configure Selenium a little bit differently. Let's start by updating our `config.js` file to store these details.

```javascript
// filename: lib/config.js
module.exports = {
  baseUrl: process.env.BASE_URL || 'http://the-internet.herokuapp.com',
  browser: process.env.BROWSER || 'firefox',
  viewportWidth: Math.floor(process.env.VIEWPORT_WIDTH) || 1024,
  viewportHeight: Math.floor(process.env.VIEWPORT_HEIGHT) || 768,
  host: process.env.HOST || "localhost",
  sauce: {
    username: process.env.SAUCE_USERNAME,
    accessKey: process.env.SAUCE_ACCESS_KEY,
    browserName: process.env.BROWSER_NAME || 'internet explorer',
    browserVersion: process.env.BROWSER_VERSION || "11.0"
    platformName: process.env.PLATFORM_NAME || "Windows 7",
  },
}
```

In addition to the `baseUrl`, `browser`, and `viewportSize` variables, we've added some more (e.g., `host`, `username`, `accessKey`, `platform`, `browserName`, and `version`).

`host` enables us to specify whether our tests run locally or on Sauce Labs. The others are stored under a key `sauce` key to make their use explicit.

With the combination of `platform`, `browserName`, and `version` we can specify which browser and operating system combination we want our tests to run on. You can see a full list of Sauce's available platform options [here](https://saucelabs.com/platforms/). They also have a handy configuration generator (which will tell you what values to plug into your test suite at run-time) [here](https://docs.saucelabs.com/reference/platforms-configurator/).

Now we can update our Driver Factory to work with these new values and connect to Sauce Labs.

```javascript
// filename: lib/DriverFactory.js
// ...
class DriverFactory {
  constructor(config) {
    this.config = config
  }

  _configure() {
    let builder = new Builder()
    switch (this.config.host) {
      case 'saucelabs':
        const url = 'http://ondemand.saucelabs.com:80/wd/hub'
        builder.usingServer(url)
        builder.withCapabilities(this.config.sauce)
        break
      case 'localhost':
        process.env.PATH +=
          path.delimiter + path.join(__dirname, '..', 'vendor')
        builder.forBrowser(this.config.browser)
        break
    }
    return builder
  }
// ...
  async build(testName, hasEyesCommands = false) {
    this.testName = testName
    this.driver = await this._configure().build()
    if (hasEyesCommands) this.driver = await this._openEyes()
    return this.driver
  }
}

module.exports = DriverFactory
```

We create a method to configure the builder object for Selenium (e.g., `_configure()`), wrapping everything in a conditional check against `config.host`. If it's set to `'saucelabs'` then we specify the `url` for their on-demand end-point and pass in the capabilities that we want (e.g., everything specified under `sauce` in config.js). If `config.host` is set to `'localhost'` then we handle browser execution just like before (adding the path to the vendor directory to the execution path and launching a browser locally).

If we save everything and run our tests they will execute in Sauce Labs and on the account dashboard we'll see our tests running in Internet Explorer 11 on Windows 7.

To run the tests on different browser and operating system combinations, then simply provide their values as command-line options (e.g., `BROWSER_NAME='name' BROWSER_VERSION=version PLATFORM_NAME='os' mocha`). For a full list of possible options be sure to check out [the Sauce Labs Platform Configurator](https://wiki.saucelabs.com/display/DOCS/Platform+Configurator#/).

### Part 2: Test Name

It's great that our tests are running on Sauce Labs. But we're not done yet because the test name in each Sauce job is getting set to `unnamed job`. This makes it extremely challenging to know what test was run in the job. To remedy this we'll need to pass the test name to Sauce Labs somehow.

Given the order of operations of our test code, we only have access to the test name after the test has completed. So we'll account for this in both the `quit` method of our Driver Factory and the global `afterEach` in our Base Test. Let's start with the Driver Factory first.

```javascript
// filename: lib/DriverFactory.js
// ...
  async quit() {
    if (this.config.host === 'saucelabs') {
      this.driver.executeScript('sauce:job-name=' + this.testName)
    }
    await this.driver.quit()
    if (this.eyes) await this.eyes.abortIfNotClosed()
  }
}

module.exports = DriverFactory
```

With Selenium we have access to execute JavaScript directly in the browser session. When executing tests in Sauce Labs we have access to pass information to them about the current job through JavaScript calls. We take advantage of this fact by specifying the name of the job for the session. And we only want this to happen when our tests are executing in Sauce Labs, so we wrap this in a conditional check.

The test name (e.g., `testName`) was stored earlier as an argument to `build` (e.g., from the `beforeEach`) which we stored in a class variable (e.g., `this.testName`).

Now when we run our tests in Sauce Labs, [the account dashboard](https://saucelabs.com/account) will show the tests running with a correct name.

### Part 3: Test Status

There's still one more thing we'll need to handle, and that's setting the status of the Sauce Labs job after it completes.

Right now regardless of the outcome of a test, the job in Sauce Labs will register as `Finished`. Ideally we want to know if the job was a `Pass` or a `Fail`. That way we can tell at a glance if a test failed or not. With a couple of tweaks we can make this happen easily enough.

First we need to update our `build` method in the Driver Factory to grab the session ID from Selenium.

```javascript
// filename: lib/DriverFactory.js
// ...
  async build(testName, hasEyesCommands = false) {
    // ...
    this.driver = await this._configure().build()
    const { id_ } = await this.driver.getSession()
    this.sessionId = id_
    // ...
  }
```

Next, we need to update the `quit` method in the Driver Factory.

```javascript
// filename: lib/DriverFactory.js
// ...
  async quit(testPassed) {
    if (this.config.host === 'saucelabs') {
      this.driver.executeScript('sauce:job-name=' + this.testName)
      this.driver.executeScript('sauce:job-result=' + testPassed)
      if (!testPassed)
        console.log(
          'See a video of the run at https://saucelabs.com/tests/' +
            this.sessionId
        )
    }
    await this.driver.quit()
    if (this.eyes) await this.eyes.abortIfNotClosed()
  }
}

module.exports = DriverFactory
```

With the JavaScript executor we're able to pass in the test result just like the name, which we're getting as a parameter on this method. And for good measure we've also put the `testResult` to good use by outputting a URL of the Sauce Labs job to the console if there is a test failure. That way we'll have easy access to the direct URL of the job to review what happened in the test.

Now let's update the `afterEach` in our spec helper.

```javascript
// filename: test/spec_helper.js
afterEach(async function() {
  const testPassed = this.currentTest.state === 'passed'
  await driverFactory.quit(testPassed)
})
```

We grab the state of the current test (e.g., `this.currentTest.state`), check to see if it passed (e.g., `=== 'passed'`), and pass it into `driverFactory.quit`.

Now when we run our tests in Sauce Labs and navigate to [the Sauce Labs Account dashboard](https://saucelabs.com/account), we will see our tests running like before. But now there will be a proper test status when they finish (e.g., `Pass` or `Fail`) and we'll see the URL for the job in the console output as well. This enables us to easily jump to the specific job in Sauce Labs.

### Part 4: Sauce Connect

There are various ways that companies make their pre-production application available for testing. Some use an obscure public URL and protect it with some form of authentication (e.g., Basic Auth, or certificate based authentication). Others keep it behind their firewall. For those that stay behind a firewall, Sauce Labs has you covered.

They have a program called [Sauce Connect Proxy](https://wiki.saucelabs.com/display/DOCS/Setting+Up+Sauce+Connect+Proxy) that creates a secure tunnel between your machine and their private cloud. With it you can run tests in Sauce Labs and test applications that are only available on your private network.

To use Sauce Connect you need to download and run it. There's a copy for each operating system -- get yours [here](https://wiki.saucelabs.com/display/DOCS/Setting+Up+Sauce+Connect+Proxy) and run it from the command-line. In the context of our existing test code let's download Sauce Connect, unzip its contents, and store it in our `vendor` directory.

```text
├── lib
│   ├── DriverFactory.js
│   └── config.js
├── package.json
├── pages
│   ├── BasePage.js
│   ├── DynamicLoadingPage.js
│   └── LoginPage.js
├── test
│   ├── DynamicLoadingTest.js
│   ├── LoginTest.js
│   ├── mocha.opts
│   └── spec_helper.js
└── vendor
    ├── chromedriver
    └── geckodriver
    └── sc
```

Now we just need to launch the application while specifying our Sauce account credentials.

```sh
vendor/sc -u $SAUCE_USERNAME -k $SAUCE_ACCESS_KEY
// ...
Starting Selenium listener...
Establishing secure TLS connection to tunnel...
Selenium listener started on port 4445.
Sauce Connect is up, you may start your tests.
```

Now that the tunnel is established, we could run our tests against a local instance of our application (e.g., [the-internet](https://github.com/tourdedave/the-internet)). Assuming the application was set up and running on our local machine, we run our tests against it by specifying a different base URL at runtime (e.g., `BASE_URL=http://localhost:4567 mocha`) and they would work.

To see the status of the tunnel, we can view it on [the tunnel page of the account dashboard](https://saucelabs.com/beta/tunnels). To shut the tunnel down, we can do it manually from this page. Or we can issue a `Ctrl+C` command to the terminal window where it's running.

When the tunnel is closing, here's what you'll see.

```sh
Got signal 2
Cleaning up.
Removing tunnel 21ff9664b06c4edaa4bd573cdc1fbac1.
All jobs using tunnel have finished.
Waiting for the connection to terminate...
Connection closed (8).
Goodbye.
```


