# Writing Really Re-usable Test Code

In the previous chapter we stepped through creating a simple page object to capture the behavior of the page we were interacting with. While this was a good start, there's more we can do.

As our test suite grows and we add more page objects we will start to see common behavior that we will want to use over and over again throughout our suite. If we leave this unchecked we will end up with duplicative code which will slowly make our page objects harder to maintain. 

Right now we are using Selenium actions directly in our page object. While on the face of it this may seem fine, it has some long term impacts, like:

+ slower page object creation due to the lack of a simple Domain Specific Language (DSL)
+ test maintenance issues if the Selenium API changes
+ the inability to swap out the driver for your tests (e.g., mobile, REST, etc.)

With a facade layer we can easily side step these concerns by abstracting our common actions into a central place and leveraging it in our page objects.

## An Example

Let's step through an example with our login page object.

### Part 1: Create The Facade Layer

First let's add a new file called `BasePage.js` in `pages` directory.

```text
├── package.json
├── pages
│   ├── BasePage.js
│   └── LoginPage.js
└── test
    └── LoginTest.js
└── vendor
    └── geckodriver
```

Next let's populate the file.

```javascript
// filename: pages/BasePage.js
class BasePage {
  constructor(driver) {
    this.driver = driver
  }

  async visit(url) {
    await this.driver.get(url)
  }

  find(locator) {
    return this.driver.findElement(locator)
  }

  async click(locator) {
    await this.find(locator).click()
  }

  async type(locator, inputText) {
    await this.find(locator).sendKeys(inputText)
  }

  async function isDisplayed(locator) {
    return await find(locator).isDisplayed()
  }
}

module.exports = BasePage
```

In this module we declare a `BasePage` class along with methods for all of the common behavior we use with Selenium (e.g., `visit`, `find`, `click`, `type`, and `isDisplayed`). We also have a constructor that enables us to pass in and store an instance of the driver, so we don't have to explicitly pass it to the methods whenever we call them.

Now let's update our login page object to leverage this facade.

```javascript
// filename: pages/LoginPage.js
const BasePage = require('./BasePage')

const LOGIN_FORM = { id: 'login' }
const USERNAME_INPUT = { id: 'username' }
const PASSWORD_INPUT = { id: 'password' }
const SUBMIT_BUTTON = { css: 'button' }
const SUCCESS_MESSAGE = { css: '.flash.success' }
const FAILURE_MESSAGE = { css: '.flash.error' }

class LoginPage extends BasePage {
  constructor(driver) {
    super(driver)
  }

  async load() {
    await this.visit('http://the-internet.herokuapp.com/login')
    if (await !this.isDisplayed(LOGIN_FORM, 1000))
      throw new Error('Login form not loaded')
  }

  async authenticate(username, password) {
    await this.type(USERNAME_INPUT, username)
    await this.type(PASSWORD_INPUT, password)
    await this.click(SUBMIT_BUTTON)
  }

  successMessagePresent() {
    return this.isDisplayed(SUCCESS_MESSAGE, 1000)
  }

  failureMessagePresent() {
    return this.isDisplayed(FAILURE_MESSAGE, 1000)
  }
}

module.exports = LoginPage
```

A few things have changed in our Login page object. We've imported the base page class we want to use, established inheritance between the two classes, and we've swapped out all of our Selenium commands with calls to the methods in the base page object (e.g., `this.visit`, `this.type`, `this.click`, etc.). 

To establish inheritance we used the `extends` keyword (e.g., `class LoginPage extends Page {`) and called `super` from the constructor (e.g., `super(driver`). This passes the instance of Selenium to the base page object, and makes all of the base page object's methods available to our login page object.

If we save everything and run our tests they will run and pass just like before. But now our page objects are more readable, simpler to write, and easier to maintain and extend.

### Part 2: Add Some Error Handling

Remember in the previous chapter when we ran into an error with Selenium when we looked for an element that wasn't on the page? Let's address that now.

To recap -- here's the error message we saw:

```sh
NoSuchElementError: Unable to locate element: {"method":"css selector","selector":".flash.success"}
```

The important thing to note is the name of the exception Selenium offered up -- `NoSuchElementError`. Let's modify the `isDisplayed` method in our base page object to handle it.

```javascript
// filename: pages/BasePage.js
// ...
async function isDisplayed(locator) {
  try {
    return await this.find(locator).isDisplayed()
  } catch (error) {
    return false
  }
}
// ...
```

Thanks to `async` / `await` we can reliabily use a `try` / `catch` block to account for the `NoSuchElementError` and return false instead.

Now let's revisit our `'with invalid credentials'` login test and alter it so it checks to see if the success message is not present to make sure things work as we expect.

```javascript
// filename: test/LoginTest.js
//  ...
  it('with invalid credentials', async function() {
    await login.authenticate('tomsmith', 'bad password')
    assert(await !login.successMessagePresent(), 'Success message displayed')
    // ...
  })
})

```

When we save our changes and run this test it will run and pass without throwing an exception this time. Feel free to keep the test as-is, or change it back to what it was before.
