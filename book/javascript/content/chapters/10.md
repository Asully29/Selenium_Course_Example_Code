# Writing Really Re-usable Test Code

In the previous chapter we stepped through creating a simple page object to capture the behavior of the page we were interacting with. While this was a good start, there's more we can do.

As our test suite grows and we add more page objects we will start to see common behavior that we will want to use over and over again throughout our suite. If we leave this unchecked we will end up with duplicative code which will slowly make our page objects harder to maintain. 

Right now we are using Selenium actions directly in our page object. While on the face of it this may seem fine, it has some long term impacts, like:

+ slower page object creation due to the lack of a simple Domain Specific Language (DSL)
+ test maintenance issues if the Selenium API changes
+ the inability to swap out the driver for your tests (e.g., mobile, REST, etc.)

With a facade layer we can easily side step these concerns by abstracting our common actions into a central place and leveraging it in our page objects.

## An Example

Let's step through an example with our login page object.

### Part 1: Create The Facade Layer

First let's add a new folder called `lib` in the root of our project, and then create a file for the facade layer called `selenium-util.js`.

```text
├── package.json
├── pages
│   ├── LoginPage.js
│   └── Page.js
└── test
    └── LoginTest.js
└── vendor
    └── geckodriver
```

Next let's populate the file.

```javascript
// filename: lib/selenium-util.js
class Page {
  constructor(driver) {
    this.driver = driver
  }

  async visit(url) {
    await this.driver.get(url)
  }

  find(locator) {
    return this.driver.findElement(locator)
  }

  async click(locator) {
    await this.find(locator).click()
  }

  async type(locator, inputText) {
    await this.find(locator).sendKeys(inputText)
  }

  async function isDisplayed(locator) {
    return await find(locator).isDisplayed()
  }
}

module.exports = Page
```

In this module we declare functions for all of the common behavior we use with Selenium (e.g., `visit`, `find`, `click`, `type`, and `isDisplayed`). We also have a setter (e.g., `setDriver`) that enables us to pass in and store an instance of the driver, so we don't have to explicitly pass it to the functions whenever we use them.

Now let's update our login page object to leverage this facade.

```javascript
// filename: pages/LoginPage.js
const Page = require('./Page')

const LOGIN_FORM = { id: 'login' }
const USERNAME_INPUT = { id: 'username' }
const PASSWORD_INPUT = { id: 'password' }
const SUBMIT_BUTTON = { css: 'button' }
const SUCCESS_MESSAGE = { css: '.flash.success' }
const FAILURE_MESSAGE = { css: '.flash.error' }

class LoginPage extends Page {
  constructor(driver) {
    super(driver)
  }

  async load() {
    await visit('http://the-internet.herokuapp.com/login')
    if (await !isDisplayed(LOGIN_FORM, 1000))
      throw new Error('Login form not loaded')
  }

  async authenticate(username, password) {
    await type(USERNAME_INPUT, username)
    await type(PASSWORD_INPUT, password)
    await click(SUBMIT_BUTTON)
  }

  successMessagePresent() {
    return isDisplayed(SUCCESS_MESSAGE, 1000)
  }

  failureMessagePresent() {
    return isDisplayed(FAILURE_MESSAGE, 1000)
  }
}

module.exports = LoginPage
```

Two fundamental things have changed in our Login page object. We've imported all of the functions we want to use from `selenium-util`, and we've swapped out all of our Selenium commands with calls to these functions. 

If we save everything and run our tests they will run and pass just like before. But now our page objects are more readable, simpler to write, and easier to maintain and extend.

### Part 2: Add Some Error Handling

Remember in the previous chapter when we ran into an error with Selenium when we looked for an element that wasn't on the page? Let's address that now.

To recap -- here's the error message we saw:

```sh
NoSuchElementError: Unable to locate element: {"method":"css selector","selector":".flash.success"}
```

The important thing to note is the name of the exception Selenium offered up -- `NoSuchElementError`. Let's modify the `isDisplayed` method in our base page object to handle it.

```javascript
// filename: pages/page.js
// ...
async function isDisplayed(locator) {
  try {
    return await find(locator).isDisplayed()
  } catch (error) {
    return false
  }
}
// ...
```

Thanks to `async` / `await` we can reliabily use a `try` / `catch` block to account for the `NoSuchElementError` and return false instead.

Now let's revisit our `'with invalid credentials'` login test and alter it so it checks to see if the success message is not present to make sure things work as we expect.

```javascript
// filename: test/LoginTest.js
//  ...
  it('with invalid credentials', async function() {
    await login.authenticate('tomsmith', 'bad password')
    assert(await !login.successMessagePresent(), 'Success message displayed')
    // ...
  })
})

```

When we save our changes and run this test it will run and pass without throwing an exception this time. Feel free to keep the test as-is, or change it back to what it was before.
