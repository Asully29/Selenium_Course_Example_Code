# Leveling Up Your Assertions

As we saw in Chapter 6, you can find an element and assert something about it (e.g., is it displayed). This is a good start, but there's a lot of opportunity for improvement since assertions like this can give you a false sense of security.

Sure, the element is there, but what does it look like? The application could be working fine from a functional perspective but appear broken to the user due to visual anomalies in the application.

This is where automated visual testing comes in.

## An Example

With automated visual testing we can gain the confidence that the feature we're testing appears as we expect. There are lots of solutions out there for visual testing (you can see a list [here](https://applitools.com/blog/how-to-do-visual-testing-with-selenium)). We're going to step through using [Applitools Eyes](https://applitools.com).

__NOTE: You'll first need to sign up for an account. There's a free tier you can sign up for to get started. [Go here for details](https://applitools.com/users/register).__

### Part 1: Initial Setup

There are a few things we'll need to do in our test.

First, we'll need to require the Eyes class out of the `eyes-selenium` library and declare an `eyes` variable. This is where we'll to store instances of Eyes that get created for the test.

```javascript
// filename: test/LoginTest.js
// ...
const { Eyes } = require('@applitools/eyes-selenium')

describe('Login', function() {
  this.timeout(30000)
  let driver
  let eyes
// ...
```

Next, in the test's `beforeEach` we'll wire up the code which connects the test to Applitools.

```javascript
// filename: test/LoginTest.js
// ...
  beforeEach(async function() {
    // ...
    eyes = new Eyes()
    eyes.setApiKey(process.env.APPLITOOLS_API_KEY)
    driver = await eyes.open(
      driver,
      'the-internet',
      this.currentTest.fullTitle(),
      {
        width: 1024,
        height: 768,
      }
    )
  })
```

We create an instance of Eyes, specify our account API key (by pulling it from an environment variable), and open a session with Applitools (e.g., `eyes.open`). When opening a session we provide the instance of Selenium, some metadata (e.g., the application name and the name of the test that's running), and the viewport size we'd like the browser to use. We store the end result of `eyes.open` in the `driver` variable.

__NOTE: For details on how to get your API key, go [here](https://applitools.com/docs/topics/overview/obtain-api-key.html).__

Now to add a visual assertion to our test.

```javascript
// filename: test/LoginTest.js
// ...
  it('with valid credentials', async function() {
    // ...
    await eyes.checkWindow('Logged in')
    await eyes.close()
  })
})
```

With `eyes.checkWindow` we're able to take a screenshot of the entire page our test is on, establish a baseline for the page, and use that baseline as the point of comparison for future test runs. With this command, you can either specify a descriptor (e.g., `Logged in`), or nothing.

At the end of the test we need to call `eyes.close()` to end the Eyes session. We put it at the end of the test (and not in the `afterEach`) because if there are visual differences found we want the test to fail along with a URL in the failure output pointing to the job in the Applitools Eyes dashboard for further review.

As a matter of cleanup, we'll also want to update our test's teardown as well.

```javascript
// filename: test/LoginTest.js
// ...
  afterEach(async function() {
    await driver.quit()
    await eyes.abortIfNotClosed()
  })
// ...
```

If for some reason an Eyes session wasn't successfully closed, then we'll want to abort it after quitting the Selenium instance (e.g., `eyes.abortIfNotClosed()`).

### Part 2: Targeted Runs

Not all tests might have visual assertions. If that's the case, then we don't want to start an Eyes session needlesly. To account for this, we'll want to make it so an Eyes session is opened only if a test contains Eyes commands.

```javascript
// filename: test/LoginTest.js
// ...
  beforeEach(async function() {
    // ...
    const hasEyesCommands = this.currentTest.body.match(/eyes\./)
    if (hasEyesCommands) {
      eyes = new Eyes()
      eyes.setApiKey(process.env.APPLITOOLS_API_KEY)
      driver = await eyes.open(
        driver,
        'the-internet',
        this.currentTest.fullTitle(),
        {
          width: 1024,
          height: 768,
        }
      )
    }
  })
```

Similar to how we accessed the test's name (to pass to `eyes.open`), we can also access the `body` of the test.

This contains the test's commands, which we can search through and look to see if there are any which match `eyes.`. If there is a match, the search will return `true`. If no, then it will return `false`. We store the result in a variable called `hasEyesCommands` (for readability) and use it in a conditional. If it's `true`, we create the Eyes instance. If it's `false`, we don't.

## Outro

If you're interested in learning more about "why" and "when" to use automated visual testing, you can check out [this introductory blog post series I wrote on the topic](https://applitools.com/blog/visual-regression-testing-selenium).
