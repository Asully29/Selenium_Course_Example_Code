# Writing Resilient Test Code

Ideally you should be able to write your tests once and run them across all supported browsers. While this is a rosy proposition, there is some work to make this a reliable success. And sometimes there may be a hack or two involved. But the lengths you must go really depends on the browsers you care about and the functionality you're dealing with in your application.

By using high quality locators we're already in good shape, but there are still some issues to deal with. Most notably... timing. This is especially true when working with dynamic, JavaScript heavy pages (which is more the rule than the exception in a majority of web applications you'll deal with).

But there is a simple approach that makes up the bedrock of reliable and resilient Selenium tests -- and that's how you wait and interact with elements. The best way to accomplish this is through the use of __explicit waits__.

## An Explicit Waits Primer

Explicit waits are applied to individual test actions. Each time you want to use one you specify an amount of time (in seconds) and the Selenium action you want to accomplish.

Selenium will repeatedly try this action until either it can be accomplished, or until the amount of time specified has been reached. If the latter occurs, a timeout exception will be thrown.

## An Example

Let's step through an example that demonstrates this against [a dynamic page on the-internet](http://the-internet.herokuapp.com/dynamic_loading/1). The functionality is pretty simple -- there is a button. When you click it a loading bar appears for 5 seconds. After that it disappears and is replaced with the text `Hello World!`.

### Part 1: Create A New Page Object And Update The Base Page Object

Here's the markup from the page.

```html
<div class="example">
  <h3>Dynamically Loaded Page Elements</h3>
  <h4>Example 1: Element on page that is hidden</h4>

  <br>

  <div id="start">
    <button>Start</button>
  </div>

  <div id="finish" style="display:none">
    <h4>Hello World!</h4>
  </div>

</div>
```

At a glance it's simple enough to tell that there are unique `id` attributes that we can use to find and click on the start button and verify the finish text.

When writing automation for new functionality like this, you may find it easier to write the test first (to get it working how you'd like) and then create a page object for it (pulling out the behavior and locators from your test). There's no right or wrong answer here. Do what feels intuitive to you. But for this example, we'll create the page object first, and then write the test.

Let's create a new page object file called `DynamicLoadingPage.js` in the `pages` directory.

```text
├── package.json
├── pages
│   ├── DynamicLoadingPage.js
│   ├── LoginPage.js
│   └── Page.js
├── test
│   └── LoginTest.js
└── vendor
    └── geckodriver
```

Next we'll specify the locators and behavior we'll want to use on this page.

```javascript
// filename: pages/DynamicLoadingPage.js
const Page = require('./Page')

const START_BUTTON = { css: '#start button' }
const FINISH_TEXT = { id: 'finish' }

class DynamicLoadingPage extends Page {
  constructor(driver) {
    super(driver)
  }

  async loadExample(exampleNumber) {
    await this.visit(
      'http://the-internet.herokuapp.com/dynamic_loading/' + exampleNumber
    )
    await this.click(START_BUTTON)
  }

  async isFinishTextPresent() {
    return this.isDisplayed(FINISH_TEXT, 10000)
  }
}

module.exports = DynamicLoadingPage
```

Since there are two dynamic loading examples to choose from on the-internet we created the method `loadExample`. It accepts a number as an argument so we can specify which of the examples we want to visit and start.

And similar to our Login page object, we have a display check for the finish text (e.g., `finishTextPresent`). This check is slightly different though. Notice that it has a second argument (an integer value of `10000`). This is a bit of aspirational code that we'll need to write. And this millisecond argument is how we'll specify how long we'd like Selenium to wait for an element to be displayed before giving up.

Let's update the `isDisplayed` method our base page object to offer this behavior.

```javascript
// filename: pages/Page.js
const Until = require('selenium-webdriver').until
// ...
  async isDisplayed(locator, timeout) {
    if (timeout) {
      await this.driver.wait(Until.elementLocated(locator), timeout)
      await this.driver.wait(
        Until.elementIsVisible(this.find(locator)),
        timeout
      )
      return true
    } else {
      try {
        return await this.find(locator).isDisplayed()
      } catch (error) {
        return false
      }
    }
  }
}
// ...
```

Selenium comes with a wait function which we require and store in a variable.

We then update the `isDisplayed` function to take an additional argument and use the `Until` variable we just created -- calling `driver.wait`, providing an initial condition that we want to wait for (e.g., wait until the element is located), the locator to wait for, and the timeout (e.g., `(Until.elementLocated(locator), timeout)`).

The ensures the element is on the page, so we can then check to see that it is displayed with another explicit wait (e.g., `(Until.elementIsVisible(find(locator))`). If it's successful, then we return `true`.

__NOTE: We have to wait for an element to be present before doing a display lookup because the display lookup requires the use of a found element.__

In the `else` block we account for the case where no timeout is provided when calling this function. When that happens the original behavior will be used (e.g., see if an element is displayed without waiting).

There are other conditions you can wait for besides `elementLocated` or `elementIsVisible`. You can find a list [here in the API documentation](http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/until.html).

## More On Explicit Waits

The major benefit of explicit waits is that if the behavior on the page takes longer than we expect (e.g., due to slow load times, or a feature change), we can simply adjust a single wait time to fix the test -- rather than increase a blanket wait time (which impacts every test). And since the wait is dynamic (e.g., constantly polling), it won't take the full amount of time to complete (like a hard-coded sleep would).

If you're thinking about mixing explicit waits with an implicit wait -- DON'T. If you use both together you could run into issues later on due to inconsistent implementations of the implicit wait functionality across local and remote browser drivers. Long story short, you'll end up with randomly failing tests that will be hard to debug. You can read more about the specifics [here](http://stackoverflow.com/questions/15164742/combining-implicit-wait-and-explicit-wait-together-results-in-unexpected-wait-ti#answer-15174978).

A better approach would be to set a default timeout on the explicit wait method (e.g., `async function isDisplayed(locator, timeout = 5000) {`) and use it where your tests need to account for some delay. This would make specifying a timeout optional (e.g., only necessary when you need a different time than this default). But if you do this it's important to set to a reasonably sized timeout. You want to be careful not to make it too high. Otherwise the tests that use it and don't specify their own timeout can take longer than they need to. But set it too low and your tests can be brittle, forcing you to run down trivial and transient issues.

### Part 2: Write A Test To Use The New Page Object

Now that we have our new page object and an updated base page, it's time to write our test to use it.

Let's create a new file called `DynamicLoadingTest.js` in the `test` directory.

```text
├── package.json
├── pages
│   ├── DynamicLoadingPage.js
│   ├── LoginPage.js
│   └── Page.js
├── test
│   ├── DynamicLoadingTest.js
│   └── LoginTest.js
└── vendor
    └── geckodriver
```

The contents of this test file are similar to `LoginTest.js` with regards to its setup and structure.

```javascript
// filename: test/DynamicLoadingTest.js
const { Builder } = require('selenium-webdriver')
const path = require('path')
const assert = require('assert')
const DynamicLoadingPage = require('../pages/DynamicLoadingPage')

describe('Dynamic Loading', function() {
  this.timeout(30000)
  let dynamicLoading

  beforeEach(async function() {
    const vendorDirectory =
      path.delimiter + path.join(__dirname, '..', 'vendor')
    process.env.PATH += vendorDirectory
    driver = await new Builder().forBrowser('firefox').build()
    dynamicLoading = new DynamicLoadingPage(driver)
  })

  afterEach(async function() {
    await driver.quit()
  })

  it('hidden element', async function() {
    await dynamicLoading.loadExample('1')
    assert(
      await dynamicLoading.isFinishTextPresent(),
      true,
      'Finish text not displayed'
    )
  })
})
```

In `beforeEach` we've omitted the Eyes configuration, since we won't be using it in these tests.

In our test (e.g., `'hidden element'`) we are visiting the first dynamic loading example and clicking the start button (which is accomplished in `dynamicLoading.loadExample('1');`). We're then asserting that the finish text gets displayed.

When we save this and run it (e.g., `mocha test/DynamicLoadingTest.js` from the command-line) it will:

+ Launch a browser
+ Visit the page
+ Click the start button
+ Wait for the loading bar to complete
+ Find the finish text
+ Assert that it is displayed.
+ Close the browser

### Part 3: Add A New Test

Let's step through one more example to see if our explicit wait holds up.

[The second dynamic loading example](http://the-internet.herokuapp.com/dynamic_loading/2) is laid out similarly to the last one. The difference is that it renders the final text __after__ the progress bar completes (whereas the previous example had the element on the page but it was hidden until the progress bar finished).

Here's the markup for it.

```html
<div class="example">
  <h3>Dynamically Loaded Page Elements</h3>
  <h4>Example 2: Element rendered after the fact</h4>

  <br>

  <div id="start">
    <button>Start</button>
  </div>

  <br>
</div>
```

In order to find the selector for the finish text element we need to inspect the page _after_ the loading bar sequence finishes. Here's what it looks like.

```html
<div id="finish" style=""><h4>Hello World!</h4></div>
```

Let's add a second test to `DynamicLoadingTest.js` called `'rendered element'` that will load this second example and perform the same check as we did for the previous test.

```javascript
// filename: test/DynamicLoadingTest.js
// ...
  it('rendered element', async function() {
    await dynamicLoading.loadExample('2')
    assert(
      await dynamicLoading.isFinishTextPresent(),
      true,
      'Finish text not displayed'
    )
  })
```

When we run both tests (e.g., `mocha test/DynamicLoadingTest.js` from the command-line) we will see that the same approach will work in both cases of how the page is constructed.

## Browser Timing

Using explicit waits gets you pretty far. But there are a few things you'll want to think about when it comes to writing your tests to work on various browsers.

It's simple enough to write your tests locally against Firefox and assume you're all set. But once you start to run things against other browsers you may be in for a surprise. The first thing you're likely to run into is the speed of execution. A lot of your tests will start to fail when you point them at either Chrome or Internet Explorer, and likely for different reasons.

Chrome execution can sometimes be faster than Firefox, so you could see some odd timeout failures. This is an indicator that you need to add explicit waits to parts of your page objects that don't already have them. And the inverse is true when running things against Internet Explorer. This is an indicator that your explicit wait times are not long enough since the browser is taking longer to respond -- so your tests timeout.

The best approach to solve this is an iterative one. Run your tests in a target browser and see which ones fail. Take each failed test, adjust your code as needed, and re-run it against the target browser until they all pass. Repeat for each browser you care about until everything is green.

## Closing Thoughts

By explicitly waiting to complete an action, our tests are in a much more resilient position because Selenium will keep trying for a reasonable amount of time rather than trying just once. And each action can be tuned to meet the needs of each circumstance. Couple that with the dynamic nature of explicit waits, and you have something that will work in a multitude of circumstances -- helping you endure even the toughest of browsers to automate.

This is one of the most important concepts in testing with Selenium. Use explicits waits often.
