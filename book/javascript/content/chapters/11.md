# Prepping For Use

Now that we have some tests and page objects, we'll want to start thinking about how to structure our test code to be more flexible. That way it can scale to meet our needs.

## Part 1: Global Setup & Teardown

We'll start by pulling the Selenium setup and teardown out of our tests and into a central location.

We'll create three things. A class that will contain the creation and destruction of our Selenium instances (a.k.a. a Driver Factory), a helper that all tests will pull from, and an option file Mocha uses to store commonly used command-line arguments.

In the `lib` directory we'll create a new file called `DriverFactory.js`, and in the `test` directory we'll create files called `spec_helper.js` and `mocha.opts`.

```text
├── lib
│   └── DriverFactory.js
├── package.json
├── pages
│   ├── BasePage.js
│   ├── DynamicLoadingPage.js
│   └── LoginPage.js
├── test
│   ├── DynamicLoadingTest.js
│   ├── LoginTest.js
│   ├── mocha.opts
│   └── spec_helper.js
└── vendor
    └── geckodriver
```

Here are the initial contents of the Driver Factory.

```javascript
// filename: lib/DriverFactory.js
const path = require('path')
const { Builder } = require('selenium-webdriver')

class DriverFactory {
  async build() {
    process.env.PATH += path.delimiter + path.join(__dirname, '..', 'vendor')
    this.driver = await new Builder().forBrowser('firefox').build()
  }

  async quit() {
    await this.driver.quit()
  }
}

module.exports = DriverFactory
```

After requiring our requisite libraries, we declare a class along with two methods -- `build`, and `quit`. `build` is responsible for creating an instance of Selenium and `quit` is responsible for destroying the Selenium instance.

The class ends with `module.exports`, just like in previous classes we've created.

Now to update our `mocha.opts` file. It's a small change that will help us clean up the hard-coded timeout that we've needed to specify in each test.

```javascript
// filename: test/mocha.opts
-t 60000
```

Now let's put everything to use in our spec helper.

```javascript
// filename: test/spec_helper.js
const DriverFactory = require('../lib/DriverFactory')
const driverFactory = new DriverFactory()

beforeEach(async function() {
  await driverFactory.build()
})

afterEach(async function() {
  await driverFactory.quit()
})
```

In Mocha, when you specify before and after hooks outside of a test class they are used globally for all tests. These are referred to as root-level hooks. 

At the top of the spec helper we require the Driver Factory and create a new instance of it, storing it in a variable. 

In `beforeEach` we grab the name of the currently running test, check whether or not there are any visual testing commands using Applitools Eyes, and then we create a driver instance and store it in a variable on `this` (which will make it accessible to the test). We also store an instance of Eyes on `this`.

In `afterEach` we call the `quit` method in the Driver Factory to destroy the Selenium instance and abort any lingering Eyes sessions (if they exist).

Now to update our tests.

```javascript
// filename: test/LoginTest.js
require('./spec_helper')
const assert = require('assert')
const LoginPage = require('../pages/LoginPage')

describe('Login', function() {
  let login

  beforeEach(async function() {
    login = new LoginPage(this.driver)
    await login.load()
  })

  it('with valid credentials', async function() {
    await login.authenticate('tomsmith', 'SuperSecretPassword!')
    assert(await login.successMessagePresent(), 'Success message not displayed')
  })

  it('with invalid credentials', async function() {
    await login.authenticate('tomsmith', 'bad password')
    assert(await login.failureMessagePresent(), 'Failure message not displayed')
  })
})

```

```javascript
// filename: test/DynamicLoadingTest.js
require('./spec_helper')
const assert = require('assert')
const DynamicLoadingPage = require('../pages/DynamicLoadingPage')

describe('Dynamic Loading', function() {
  let dynamicLoading

  beforeEach(async function() {
    dynamicLoading = new DynamicLoadingPage(this.driver)
  })

  it('hidden element', async function() {
    await dynamicLoading.loadExample('1')
    assert(
      await dynamicLoading.isFinishTextPresent(),
      true,
      'Finish text not displayed'
    )
  })

  it('rendered element', async function() {
    await dynamicLoading.loadExample('2')
    assert(
      await dynamicLoading.isFinishTextPresent(),
      true,
      'Finish text not displayed'
    )
  })
})
```

In order to use the spec helper we just need to require it.

Then we're able to remove the creation and storing of a driver instance in `beforeEach` and leverage the driver variable stored on `this` instead. We're also able to remove the `afterEach` method entirely.

If we save our files and run our tests (e.g., `mocha` from the command-line) they should work just like before.

## Part 2: Base URL

It's a given that we'll need to run our tests against different environments (e.g., localhost, test, staging, production, etc.). So let's make it so we can specify a different base URL for our tests at runtime.

First, let's create a file called `config.js` in the `lib` directory.

```text
├── lib
│   ├── config.js
│   └── DriverFactory.js
├── package.json
├── pages
│   ├── BasePage.js
│   ├── DynamicLoadingPage.js
│   └── LoginPage.js
├── test
│   ├── DynamicLoadingTest.js
│   ├── LoginTest.js
│   ├── mocha.opts
│   └── spec_helper.js
└── vendor
    └── geckodriver
```

In it we'll specify a variable for `baseUrl` that will grab and store an environment. If one is not provided then a sensible default will be used.

```javascript
// filename: lib/config.js
module.exports = {
  baseUrl: process.env.BASE_URL || 'http://the-internet.herokuapp.com'
};
```

Now let's update the visit method in the base page object to use this config object.

```javascript
// filename: pages/BasePage.js
const config = require('./config')
// ...
async function visit(url) {
  if (url.startsWith('http')) {
    await this.driver.get(url)
  } else {
    await this.driver.get(config.baseUrl + url)
  }
}

```

In `visit` there could be a case where we'll want to navigate to a full URL so to be safe we've added a conditional check of the `url` parameter to see if a full URL was passed in. If so, we visit it. If not, `config.baseUrl` is combined with the URL path passed in as an argument to create the full URL (e.g., `config.baseUrl + url`) and visit it.

Now all we need to do is update our page objects so they're no longer using hard-coded URLs.

```javascript
// filename: pages/LoginPage.js
// ...
  async load() {
    await this.visit('/login')
    if (!(await this.isDisplayed(LOGIN_FORM, 1000)))
      throw new Error('Login form not loaded')
  }
// ...
```

```javascript
// filename: pages/DynamicLoadingPage.js
// ...
  async loadExample(exampleNumber) {
    await this.visit('/dynamic_loading/' + exampleNumber)
    await this.click(START_BUTTON)
  }
// ...
```

## Outro

Now when running our tests, we can specify a different base URL by providing some extra information at run-time (e.g., `BASE_URL=url mocha`). We're also in a better position now with our setup and teardown abstracted into a central location.

Now we can easily extend our test framework to run our tests on other browsers.


