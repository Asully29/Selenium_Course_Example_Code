# Automating Your Test Runs

You'll probably get a lot of mileage out of your test suite in its current form if you just run things from your computer, look at the results, and tell people when there are issues. But that only helps you solve part of the problem.

The real goal in test automation is to find issues reliably, quickly, and automatically. We've built things to be reliable and quick. Now we need to make them run on their own, and ideally, in sync with the development workflow you are a part of.

To do that we need to use a Continuous Integration server.

## A Continuous Integration Server Primer

A Continuous Integration server (a.k.a. CI) is responsible for merging code that is actively being developed into a central place (e.g., "trunk", "head", or "master") frequently (e.g., several times a day, or on every code commit) to find issues early so they can be addressed quickly — all for the sake of releasing working software in a timely fashion.

With CI we can automate our test runs so they can happen as part of the development workflow. The lion’s share of tests that are typically run on a CI Server are unit (and potentially integration) tests. But we can very easily add in our Selenium tests too.

There are numerous CI Servers available for use today, most notably:

+ [Bamboo](https://www.atlassian.com/software/bamboo)
+ [CircleCI](https://circleci.com)
+ [Jenkins](https://jenkins.io)
+ [TravisCI](https://travis-ci.org/)

Let's pick one and step through an example.

## A CI Example

[Jenkins](https://jenkins.io) is a fully functional, widely adopted, free and open-source CI server. Its a great candidate for us to try.

Lets start by setting it up on the same machine as our test code. Keep in mind that this isn’t the "proper" way to go about this — its merely beneficial for this example. To do it right, the Jenkins server (e.g., master node) would live on a machine of its own.

### Part 1: Quick Setup

A simple way to get started is to grab the latest Jenkins war file. You can grab it from the [Jenkins download page](https://jenkins.io/download/).

Once downloaded, launch it from the command-line and follow the setup steps provided.

```text
> java -jar jenkins.war
// ...
hudson.WebAppMain$3 run
INFO: Jenkins is fully up and running
```

You will now be able to use Jenkins by visiting http://localhost:8080/ in your browser.

![Jenkins Home Screen](jenkins-home-screen.png)

__NOTE: Before moving to the next step, click `ENABLE AUTO-REFRESH` at the top right-hand side of the page. Otherwise you'll need to manually refresh the page (e.g., when running a job and waiting for results to appear).__

### Part 2: Job Creation And Configuration

Now that Jenkins is loaded in the browser, let's create a Job and configure it to run our `shallow` tests against Chrome on Windows 10.

+ Click `New Item` from the top-left of the Dashboard
+ Give it a name (e.g., `Shallow Tests Chrome 50 Windows 10`)
+ Select the `Freestyle project` option
+ Click `OK`

![Jenkins New Job](jenkins-job-creation.png)

This will load a configuration screen for the Jenkins job.

![Jenkins Job Configuration](jenkins-job-config-screen.png)

+ In the `Advanced Project Options` section select the `Advanced` button
+ Choose the checkbox for `Use custom workspace`
+ Provide the full path to your test code
+ Leave the `Display Name` field blank

![Jenkins Advanced Job Configuration](jenkins-job-config-advanced.png)

__NOTE: Ideally, your test code would live in a version control system and you would configure your job (under `Source Code Management`) to pull it in and run it. To use this approach you may need to install a plugin to handle it. For more info on plugins in Jenkins, go [here](https://plugins.jenkins.io).__

+ Scroll down to the `Build` section and select `Add build step`
+ Select `Execute shell`
+ Specify the commands needed to launch the tests

![Jenkins Job Configuration Add Build Step](jenkins-job-config-add-build-step.png)

![Jenkins Job Configuration Build Step](jenkins-job-config-build-step.png)

```text
mvn clean test
```

+ Under `Post-build Actions` select `Add post build action`
+ Select `Publish JUnit test result report`
+ Add the pattern for the XML result file(s) the test run will generate -- `target/surefire-reports/*.xml`
+ Click `Save`

__NOTE: If this post build action isn't available to you, you will need to install [the JUnit Jenkins plugin](https://plugins.jenkins.io/junit).__

![Jenkins Job Add Post Build Action](jenkins-job-add-post-build-action.png)

![Jenkins Job Post Build Action](jenkins-job-post-build-action.png)

Now our tests are ready to be run, but before we do, let's go ahead and add a failing test so we can demonstrate the test report.

### Part 3: Force A Failure

Let's add a new test method to `TestLogin.java` that will fail every time we run it.

```java
// filename: tests/TestLogin.java
// ...
    @Test
    @Category(Shallow.class)
    public void forcedFailure() {
        login.with("tomsmith", "bad password");
        assertTrue(login.successMessagePresent());
    }
}
```


This test mimics our `'failed'` test by visiting the login page and providing invalid credentials. The differences here are in the assertion and the tag. It will fail since the success message won't be present, and we want it to run as part of our `@shallow` suite.

Now let's run our Jenkins job by clicking `Build Now` from the left-hand side of the screen.

__NOTE: You can peer behind the scenes of a job while it's running (and after it completes) by clicking on the build you want from `Build History` and selecting `Console Output`. This output will be your best bet in tracking down an unexpected result.__

When the test completes, it will be marked as failed.

![Jenkins Job Screen With Failure](jenkins-job-latest-test-result.png)

When we click on `Latest Test Result` we can see the test that failed (e.g., `Login.forced failure @shallow`). The other failure listed (e.g., `,"after each" hook for "forced failure @shallow"`) is from the teardown of our test. It contains the Sauce Labs job URL.

![Jenkins Job Test Result](jenkins-job-latest-test-report.png)

If we click on the failed test we can see the stack trace from the test failure. If we click on the failure from the teardown we can see the URL to the job in Sauce Labs.

![Jenkins Job Test Result Individual](jenkins-job-test-report-sauce-url.png)

When we follow the URL to the Sauce Labs job we're able to see what happened during the test run (e.g., we can replay a video of the test, see what Selenium commands were issued, etc.).

![Sauce Labs Job](jenkins-visit-relevant-sauce-job.png)

## Notifications

In order to maximize your CI effectiveness, you'll want to send out notifications to alert your team members when there's a failure.

There are numerous ways to go about this (e.g., e-mail, chat, text, co-located visual cues, etc). Thankfully there are numerous, freely available plugins that can help facilitate whichever method you want. You can find out more about Jenkins' plugins [here](https://plugins.jenkins.io).

For instance, if you wanted to use chat notifications and you use a service like Slack, you would do a plugin search:

![Jenkins Plugin Slack](screenshot_jenkins_plugin_slack.png)

After installing the plugin, you will need to provide the necessary information to configure it (e.g., an authorization token, the channel/chat room where you want notifications to go, what kinds of notifications you want sent, etc.) and then add it as a `Post-build Action` to your job (or jobs).

After installing and configuring a plugin, when your CI job runs and fails, a notification will be sent to the chat room you configured.

## Ideal Workflow

In the last chapter we covered test grouping with categories and applied some preliminary ones to our tests (e.g., "Shallow" and "Deep"). These categories are perfect for setting up an initial acceptance test automation workflow.

To start the workflow we'll want to identify a triggering event. Something like a CI job for unit or integration tests that the developers on your team use. Whenever that runs and passes, we can trigger our "Shallow" test job to run (e.g., our smoke or sanity tests). If the job passes then we can trigger a job for "Deep" tests to run. Assuming that passes, we can consider the code ready to be promoted to the next phase of release (e.g., manual testing, push to a staging, etc.) and send out a relevant notification to the team.

__NOTE: You may need to incorporate a deployment action as a preliminary step before your "Shallow" and "Deep" jobs can be run (to make sure your tests have an environment available to be run against). Consult a developer on your team for help if that's the case.__

## Outro

By using a CI Server you're able to put your tests to work by using computers for what they're good at -- automation. This frees you up to focus on more important things. But keep in mind that there are numerous ways to configure your CI server. Be sure to tune it to what works best for you and your team. It's well worth the effort.


