# Running Browsers In The Cloud

If you've ever needed to test features in an older browser like Internet Explorer 9 or 10 then odds are you ran a virtual machine (VM) on your computer with a "legit" version of Windows.

Handy, but what happens when you need to check things on multiple versions of IE? Now you're looking at multiple VMs. And what about when you need cover other browser and Operating System (OS) combinations? Now you're looking at provisioning, running, and maintaining your own set of machines and standing up something like Selenium Grid to coordinate tests across them.

Rather than take on the overhead of a test infrastructure you can easily outsource this to a third-party cloud provider like [Sauce Labs](https://saucelabs.com/).

## A Selenium `Selenium::WebDriver::Remote`, Selenium Grid, and Sauce Labs Primer

At the heart of Selenium at scale is the use of Selenium Grid and Selenium `Selenium::WebDriver::Remote`.

Selenium Grid lets you distribute test execution across several machines and you connect to it with Selenium `Selenium::WebDriver::Remote`. You tell the Grid which browser and OS you want your test to run on through the use of Selenium's class object [`:Remote::Capabilities` (i.e. `desired_capabilities`)](https://www.rubydoc.info/gems/selenium-webdriver/0.0.28/Selenium/WebDriver/Remote/Capabilities), and its various subclasses for specific browser options (`:Chrome::Options`, `:Firefox::Options`, etc.)

Generally speaking, running tests on Sauce Labs is similar to running tests on a Selenium Grid behind the scenes. They receive and execute tests through Selenium `Selenium::WebDriver::Remote` with the browser and operating system that you set. Sauce Labs has [specific language bindings](https://github.com/saucelabs/sauce_bindings) that act as wrappers for supported programming languages. This makes connecting and working with the Sauce Labs platform much easier.

Let's dig in with an example.

## An Example

### Part 1: Initial Setup

__NOTE: You'll need an account to use Sauce Labs. Their [free trial](https://saucelabs.com/signup/trial) offers enough to get you started. And if you're signing up because you want to test an open source project, then be sure to check out their [Open Sauce account](https://saucelabs.com/open-source).__

With Sauce Labs we need to provide our credentials, specifics about what we want in our test environment, and configure Selenium a little bit differently than we have been. Let's start by updating our `config.rb` file.

```ruby
# filename: spec/config.rb
module Config
  def config
    {
      base_url:         ENV['BASE_URL']         || 'http://the-internet.herokuapp.com',
      host:             ENV['HOST']             || 'saucelabs',
      browser_name:     ENV['BROWSER_NAME']     || 'internet_explorer',
      browser_version:  ENV['BROWSER_VERSION']  || '11',
      platform_name:    ENV['PLATFORM_NAME']    || 'Windows 10',
      sauce_username:   ENV['SAUCE_USERNAME'],
      sauce_access_key: ENV['SAUCE_ACCESS_KEY']
    }
  end
end
```

Notice the use of a host environment variable (e.g., `ENV['HOST'] = 'saucelabs'`). This is what we'll use in our `spec_helper` file to determine whether to run things locally or in the cloud. We can specify our Sauce Labs credentials here by hard-coding them (not recommended) , or we can reference them through an environment variable we configure on our machine or specify them at run-time (recommended). And we'll use the `BROWSER_NAME`, `BROWSER_VERSION`, and `PLATFORM_NAME` environment variables to populate the `Capabilities` object.

Now to update our `spec_helper.rb` file.

```ruby
# filename: spec/spec_helper.rb
require 'selenium-webdriver'
require_relative 'config'

RSpec.configure do |c|
  include Config

  c.before do |example|
    case config[:host] when 'saucelabs'
      caps = Selenium::WebDriver::Remote::Capabilities.send(config[:browser_name])
      caps[:browser_version] = config[:browser_version]
      caps[:platform_name] = config[:platform_name]
      url = "https://#{config[:sauce_username]}:#{config[:sauce_access_key]}@ondemand.saucelabs.com/wd/hub"
      @driver = Selenium::WebDriver.for(
        :remote,
        url: url,
        desired_capabilities: caps)
    when 'localhost'
      case config[:browser_name]
      when 'firefox'
        driver_path = File.join(Dir.pwd, 'vendor', 'geckodriver')
        if File.file? driver_path
          service = Selenium::WebDriver::Service.firefox(path: driver_path)
        end
      when 'chrome'
        driver_path = File.join(Dir.pwd, 'vendor', 'chromedriver')
        if File.file? driver_path
          service = Selenium::WebDriver::Service.chrome(path: driver_path)
        end
      end
      if service
        @driver = Selenium::WebDriver.for config[:browser_name].to_sym, service: service
      else
        @driver = Selenium::WebDriver.for config[:browser_name].to_sym
      end
    end
  end

  c.after do |example|
    @driver.quit
  end

end
```

We've taken our browser conditional and made it nested underneath one for the host environment variable. If the host is set to `'saucelabs'`, then we configure the capabilities for Selenium Remote, passing in the requisite information that we will need for our Sauce Labs session. Otherwise, our tests will run locally.

There are a couple of things in this example that may be worth elaborating on.

We are using something called metaprogramming (a.k.a. code that writes code) when we are calling `Selenium::WebDriver::Remote::Capabilities`. We are using the `.send` method to pass in the environment variable. The value of which, in this case, is the same name as the method to configure Selenium Remote to use Internet Explorer. So, we are in effect, specifying `Selenium::WebDriver::Remote::Capabilitites.internet_explorer`. And if we were to specify 'chrome' for `ENV['browser']`, then it would give us `Selenium::WebDriver::Remote::Capabilities.chrome`.

For the `url`, we are constructing a URL to Sauce's Selenium Grid which contains our account credentials (e.g., a basic auth URL) through what's known as string interpolation. This is why we are using double-quoted strings. If they were single-quotes then we wouldn't be able to do it.

Now if we run our test suite (`rspec`) and navigate to [our Sauce Labs Account page](https://saucelabs.com/account) then we should see each of the tests running in their own job, with proper names, against Internet Explorer 11.

### Part 2: Test Name

In order to get the most out of our test runs in Sauce Labs, we'll want to pass some additional metadata like the test name. That way we'll be able to correlate a test run with the job in Sauce Labs so we can easily find it and view the reporting (e.g., video recording, screenshots, logs, etc.) if there was an issue found during the run.

To do that, it's a simple matter of using Selenium's JavaScript executor. We can pull the name of the test out of RSpec and pass it to Sauce Labs.

Let's update our teardown to handle this.

```ruby
# filename: spec/spec_helper.rb
# ...
  c.after do |example|
    begin
      if config[:host] == 'saucelabs'
        @driver.execute_script("sauce:job-name=#{example.full_description}")
      end
    ensure
      @driver.quit
    end
  end

end
```

### Part 3: Test Status

The only thing missing now is the pass/fail status of the job. In our local terminal window everything should be coming up green. But in the Sauce Labs dashboard each of the test jobs will just say __Finished__. This will make our results less useful in the long run, so let's fix it.

This is also something we can handle with the JavaScript executor in our teardown.

Before we issue `@driver.quit` we will want to grab the session ID from our `@driver` object (which is also the job ID in Sauce Labs) and use it to set the status of the job based on the test result.

```ruby
# filename: spec/spec_helper.rb
#...
  c.after do |example|
    begin
      if config[:host] == 'saucelabs'
        test_passed = example.exception.nil?
        @driver.execute_script("sauce:job-name=#{example.full_description}")
        @driver.execute_script("sauce:job-result=#{test_passed}")
        if !test_passed
          puts "Watch a video of the test at https://saucelabs.com/tests/#{@driver.session_id}"
        end
      end
    ensure
      @driver.quit
    end
  end

end
```

For bonus points, we've also added console output of the URL of the job in Sauce Labs when there is a failure. For good measure, we've also wrapped everything in a `begin`/`ensure` block to make sure that `driver.quit` always gets called, regardless of the outcome of the other commands in the teardown.

Now when we run our tests (`rspec`) and navigate to [our Sauce Labs Account page](https://saucelabs.com/account), we should see our tests running like before. But now when they finish there should be a proper test status (e.g., 'Pass' or 'Fail').

And if a test fails, a URL to the Sauce Labs job will appear in the console output.

> Watch a video of the test at https://saucelabs.com/tests/8b075a49cb20477f9aa820de4d196ac5

### Part 4: Accessing Private Apps

There are various ways that companies make their pre-production application available for testing. Some use an obscure public URL and protect it with some form of authentication (e.g., Basic Auth, or certificate based authentication). Others keep it behind their firewall. For those that stay behind a firewall, Sauce Labs has you covered.

They have a program called [Sauce Connect Proxy](https://wiki.saucelabs.com/display/DOCS/Setting+Up+Sauce+Connect+Proxy) that creates a secure tunnel between your machine and their private cloud. With it you can run tests in Sauce Labs and test applications that are only available on your private network.

To use Sauce Connect you need to download and run it. There's a copy for each operating system -- get yours [here](https://wiki.saucelabs.com/display/DOCS/Setting+Up+Sauce+Connect+Proxy) and run it from the command-line. In the context of our existing test code let's download Sauce Connect, unzip its contents, and store it in our `vendor` directory.

```text
├── Gemfile
├── pages
│   ├── base_page.rb
│   ├── dynamic_loading.rb
│   └── login.rb
├── spec
│   ├── config.rb
│   ├── dynamic_loading_spec.rb
│   ├── login_spec.rb
│   └── spec_helper.rb
└── vendor
    ├── chromedriver
    ├── geckodriver
    └── sc
```

Now we just need to launch the application while specifying our Sauce account credentials.

```sh
vendor/sc -u $SAUCE_USERNAME -k $SAUCE_ACCESS_KEY
// ...
Starting Selenium listener...
Establishing secure TLS connection to tunnel...
Selenium listener started on port 4445.
Sauce Connect is up, you may start your tests.
```

Now that the tunnel is established, we could run our tests against a local instance of our application (e.g., [the-internet](https://github.com/tourdedave/the-internet)). Assuming the application was set up and running on our local machine, we run our tests against it by specifying a different base URL at runtime (e.g., `BASE_URL=http://localhost:4567 rspec`) and they would work.

To see the status of the tunnel, we can view it on [the tunnel page of the account dashboard](https://saucelabs.com/beta/tunnels). To shut the tunnel down, we can do it manually from this page. Or we can issue a `Ctrl+C` command to the terminal window where it's running.

When the tunnel is closing, here's what you'll see.

```sh
Got signal 2
Cleaning up.
Removing tunnel 21ff9664b06c4edaa4bd573cdc1fbac1.
All jobs using tunnel have finished.
Waiting for the connection to terminate...
Connection closed (8).
Goodbye.
```


