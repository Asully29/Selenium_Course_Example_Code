# Flexible Test Execution

In order to get the most out of our test runs in a CI environment we want to break up our test suite into small, relevant chunks and have separate jobs for each. This helps keep test runs fast and informative (so people on your team will care about them). [Gojko Adzic](https://gojko.net/) refers to these as "Test Packs".

The workflow is pretty straightforward. The CI Server pulls in the latest code, merges it, and runs unit tests. We then have the CI Server kick off a new job to deploy to a test server and run a subset of critical acceptance tests (e.g., smoke or sanity tests). Assuming those pass, we can have another job run the remaining tests after that (e.g., the less critical and longer running tests). [Adam Goucher refers to this strategy as a 'shallow' and 'deep' tagging model](https://github.com/adamgoucher/rspec-selenium-pageobjects#tags).
To demonstrate this, let's add tags to our tests.

## Part 1: Update Tests With Tag Metadata

RSpec comes built in with tagging support. It's a simple matter of adding a key/value pair or a symbol to denote what you want. You can place it on individual tests, or a group of tests. And you can use as many tags as you want (separating them with commas).

Let's add some to our specs, following Adam Goucher's shallow and deep approach.

```ruby
# filename: spec/dynamic_loading_spec.rb
# ...
describe 'Dynamic Loading', :deep do
# ...
```

```ruby
# filename: spec/login_spec.rb
# ...
describe 'Login', :shallow do
# ...
```

If we wanted to apply this tag directly to a test, then it would look like this:

```ruby
it 'succeeded', :shallow do
```

To run tests based on a specific tag, we will need to pass in an additional argument to RSpec. It starts with `--tag` followed by the tag value (e.g., `--tag shallow` or `--tag deep`).


## Part 2: Simple Command-line Execution

To simplify test execution from the command-line we can use a library called `Rake` to help.

With it we can specify tasks which will enable us to abstract away some of the complexity we'll need to remember to run our tests.

First, we'll need to add `rake` to our `Gemfile` and perform a `bundle install`.

```ruby
# filename: Gemfile
source 'https://rubygems.org'

gem 'rspec', '~>3.8.0'
gem 'selenium-webdriver', '~>4.0.0.alpha.2'
gem 'parallel_tests', '~>2.29.1'
gem 'rake', '~>12.3.2'
```

Next we'll want to create a `Rakefile` in the root directory of our project and add some tasks.

```sh
├── Gemfile
├── Rakefile
├── pages
│   ├── base_page.rb
│   ├── dynamic_loading.rb
│   └── login.rb
├── spec
│   ├── config.rb
│   ├── dynamic_loading_spec.rb
│   ├── login_spec.rb
│   └── spec_helper.rb
└── vendor
```

```ruby
# filename: Rakefile
def launch_in_parallel
  tags      = ENV['TAG']
  processes = ENV['PROCESSES']
  system(
    "parallel_rspec " + 
    "#{'-n ' + processes if processes} " +
    "--test-options '--order random " + "#{'--tag ' + tags if tags}' " +
    "spec"
  )
end

desc 'Run tests locally'
task :local, :browser_name do |task, args|
  ENV['HOST'] = 'localhost'
  ENV['BROWSER_NAME'] = args[:browser_name]
  launch_in_parallel
end

desc 'Run tests on Sauce Labs'
task :sauce, :browser_name, :browser_version, :platform_name do |t, args|
  ENV['BROWSER_NAME']  = args[:browser_name]
  ENV['BROWSER_VERSION'] = args[:browser_version]
  ENV['PLATFORM_NAME'] = args[:platform_name]
  launch_in_parallel
end
```

In the `launch_in_parallel` method we've abstracted launching the tests in parallel. It uses Ruby's `system` command launch a command in a shell process.

The tasks `local` and `cloud` use the `launch_in_parallel` method after setting environment variables with the values passed in.

When we save this file and run `rake -T` from the command-line, he is what we'll see.

```sh
> rake -T
rake local[browser_name]                                # Run tests locally
rake sauce[browser_name,browser_version,platform_name]  # Run tests on Sauce Labs
```

Here are some examples of the tasks being used.

```sh
rake local['chrome']
rake sauce['safari','12.0','macOS 12.14']
```


