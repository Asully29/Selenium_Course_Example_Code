# Writing Resilient Test Code

Ideally you should be able to write your tests once and run them across all supported browsers. While this is a rosy proposition, there is some work to make this a reliable success. And sometimes there may be a hack or two involved. But the lengths you must go really depends on the browsers you care about and the functionality you're dealing with in your application.

By using high quality locators we're already in good shape, but there are still some issues to deal with. Most notably... timing. This is especially true when working with dynamic, JavaScript heavy pages (which is more the rule than the exception in a majority of web applications you'll deal with).

But there is a simple approach that makes up the bedrock of reliable and resilient Selenium tests -- and that's how you wait for elements you want to interact with. The best way to accomplish this is through the use of __explicit waits__.

## An Explicit Waits Primer

[Explicit waits](https://www.selenium.dev/documentation/en/webdriver/waits/#explicit-wait) are applied to individual test actions. Each time you want to use one you specify an amount of time (in seconds) and the Selenium action action you want to accomplish. This wait strategy is in contrast to [implicit waits](https://www.selenium.dev/documentation/en/webdriver/waits/#implicit-wait), in which the WebDriver polls for a certain duration and waits for any element. Implicit waits are generally not recommended, and also mixing explicit waits with implicit waits cause negative consequences.

Selenium will repeatedly try this action until either it can be accomplished, or until the amount of time specified has been reached. If the latter occurs, a timeout exception will be thrown.

## An Example

Let's step through an example that demonstrates this against [a dynamic page on the-internet](http://the-internet.herokuapp.com/dynamic_loading/1). The functionality is pretty simple -- there is a button. When you click it a loading bar appears for 5 seconds, then disappears, and gets replaced with the text 'Hello World!'.

### Part 1: Create A New Page Object And Update The Base Page Object

Let's start by looking at the markup on the page.

```html
<div class="example">
  <h3>Dynamically Loaded Page Elements</h3>
  <h4>Example 1: Element on page that is hidden</h4>

  <br>

  <div id="start">
    <button>Start</button>
  </div>

  <div id="finish" style="display:none">
    <h4>Hello World!</h4>
  </div>

</div>
```

At a glance it's simple enough to tell that there are unique `id` attributes that we can use to reference the start button and finish text.

Let's add a page object for Dynamic Loading.

```ruby
# filename: pages/dynamic_loading.rb
require_relative 'base_page'

class DynamicLoading < BasePage

  START_BUTTON = { css: '#start button' }
  FINISH_TEXT = { id: 'finish' }

  def load(example_number)
    visit 'http://the-internet.herokuapp.com/dynamic_loading/' + example_number
    click START_BUTTON
  end

  def finish_text_present?
    wait_for(10) { is_displayed? FINISH_TEXT }
  end

end
```

At the top of the file we require our base page object and set up inheritance when declaring our class so we get our common Selenium actions. After that we wire up our locators in constants, add a method to load the example and start it (e.g., `load`), and a method to see if the finish text is present (e.g., `finish_text_present?`).

In `finish_text_present?` we are using a bit of aspirational code. We're referencing a method that hasn't been added to our base page object yet. So let's hop into our base page object and add it to the bottom of the class.

```ruby
# filename: pages/base_page.rb
# ...
  def wait_for(seconds = 15)
    Selenium::WebDriver::Wait.new(timeout: seconds).until { yield }
  end

end
```

`wait_for` is where we are defining our explicit wait. In it we are accepting an integer for the number of seconds we'd like to wait. If nothing is provided, `15` seconds will be used. We then use this value to tell the explicit wait function that Selenium offers how long to wait, and what to wait for. By using a `yield` we are able to _pass_ in a code block to run (e.g., a Selenium command surrounded by brackets (`{}`)). If this passed in code doesn't evaluate to true, the explicit wait will retry it until it can either succeed, or it reaches the timeout.

## More On Explicit Waits

The major benefit of explicit waits is that if the behavior on the page takes longer than we expect (e.g., due to slow load times, or a feature change), we can simply adjust a single wait time to fix the test -- rather than increase a blanket wait time (which impacts every test). And since the wait is dynamic (e.g., constantly polling), it won't take the full amount of time to complete (like a hard-coded sleep would).

In our page object when we're using `wait_for(10) { is_displayed? FINISH_TEXT }` we are telling Selenium to to see if the finish text is displayed on the page. It will keep trying until it either returns `true` or reaches ten seconds -- whichever comes first.

If the behavior on the page takes longer than we expect (e.g., due to slow load times, or a feature change), we can simply adjust this one wait time to fix the test rather than increase a blanket wait time (which impacts every test). And since it's dynamic, it won't always take the full amount of time to complete.

### Part 2: Write A Test To Use The New Page Object

Now that we have our page object and requisite base page methods we can create a new test to use it.

```sh
├── Gemfile
├── pages
│   ├── base_page.rb
│   ├── dynamic_loading.rb
│   └── login.rb
├── spec
│   ├── dynamic_loading_spec.rb
│   └── login_spec.rb
└── vendor
    └── geckodriver
```

```ruby
# filename: spec/dynamic_loading_spec.rb
require_relative '../pages/dynamic_loading'

describe 'Dynamic Loading' do

  before(:each) do
    driver_path = File.join(Dir.pwd, 'vendor', 'geckodriver')
    if File.file? driver_path
      service = Selenium::WebDriver::Service.firefox(path: driver_path)
      @driver = Selenium::WebDriver.for :firefox, service: service
    else
      @driver = Selenium::WebDriver.for :firefox
    end
    @dynamic_loading = DynamicLoading.new(@driver)
  end

  after(:each) do
    @driver.quit
  end

  it 'Example 1: Hidden Element' do
    @dynamic_loading.load('1')
    expect(@dynamic_loading.finish_text_present?).to be_truthy
  end

end
```

When we run it (e.g., `rspec dynamic_loading_page.rb` from the command-line) it will visit the page, click the start button, wait for the text to appear, assert the text appeared, and close the browser.

### Part 3: Add A New Test

Let's step through one more dynamic page example to see if our explicit wait approach holds up.

[This example](http://the-internet.herokuapp.com/dynamic_loading/2) is nearly identical to the last one. The only difference is that it will render the final result __after__ the progress bar completes. Otherwise, the markup is the same. So we can use the same locators.

This makes adding another test straight-forward.

```ruby
# filename: spec/dynamic_loading_spec.rb
# ...
  it 'Example 2: Rendered after the fact' do
    @dynamic_loading.load '2'
    expect(@dynamic_loading.finish_text_present?).to be_truthy
  end
end
```

When we run these tests (`rspec dynamic_loading_spec.rb` from the command-line) we can see that the explicit wait approach works for when the element is on the page but hidden and when it's rendered after the fact.

Using explicit waits gets you pretty far. But there are a few things you'll want to think about when it comes to writing your tests to work on various browsers.

It's simple enough to write your tests locally against one browser and assume you're all set. But once you start to run things against other browsers you may be in for a surprise. The first thing you're likely to run into is the speed of execution. A lot of your tests may start to fail when you point them at either Chrome or Internet Explorer, and likely for different reasons.

Chrome execution can sometimes be faster than Firefox, so you could see some odd timeout failures. This is an indicator that you need to add explicit waits to parts of your page objects that don't already have them. And the inverse is true when running things against Internet Explorer. This is an indicator that your explicit wait times are not long enough since the browser is taking longer to respond -- so your tests timeout.

The best approach to solve this is an iterative one. Run your tests in a target browser and see which ones fail. Take each failed test, adjust your code as needed, and re-run it against the target browser until they all pass. Repeat for each browser you care about until everything is green.

## Closing Thoughts

By explicitly waiting to complete an action, our tests are in a much more resilient position because Selenium will keep trying for a reasonable amount of time rather than trying just once. And each action can be tuned to meet the needs of each circumstance. Couple that with the dynamic nature of explicit waits, and you have something that will work in a multitude of circumstances -- helping you endure even the toughest of browsers to automate.

This is one of the most important concepts in testing with Selenium. Use explicits waits often.


