# Prepping For Use

Now that we have tests, page objects, and a base page object, let's package things into a more useful structure.

## Global Setup And Teardown

Now we're ready to pull the test setup and teardown actions out of our tests and into a central place. In RSpec this is straight-forward through the use of a `spec_helper` file. This can live alongside the other test files in the `spec` directory.

```sh
├── Gemfile
├── pages
│   ├── base_page.rb
│   ├── dynamic_loading.rb
│   └── login.rb
├── spec
│   ├── dynamic_loading_spec.rb
│   ├── login_spec.rb
│   └── spec_helper.rb
└── vendor
    └── geckodriver
```

```ruby
# filename: spec/spec_helper.rb
require 'selenium-webdriver'

RSpec.configure do |c|

  c.before do |example|
    driver_path = File.join(Dir.pwd, 'vendor', 'geckodriver')
    if File.file? driver_path
      service = Selenium::WebDriver::Service.firefox(path: driver_path)
      @driver = Selenium::WebDriver.for :firefox, service: service
    else
      @driver = Selenium::WebDriver.for :firefox
    end
  end

  c.after do |example|
    @driver.quit
  end

end
```

We require the Selenium library here since we're working directly with it. By having it here we can remove it from our base page object. We can also remove our Selenium commands from the `before(:each)` and `after(:each)` in our tests -- replacing them with a simple require statement at the top of the file (`require_relative 'spec_helper'`). We will also be able to remove the `after(:each)` method from our tests, leaving just the `before(:each)` for use with our page objects.

Here's what our tests look like with these changes:

```ruby
# filename: spec/login_spec.rb
require_relative 'spec_helper'
require_relative '../pages/login'

describe 'Login' do

  before(:each) do
    @login = Login.new(@driver)
  end

  it 'succeeded' do
    @login.with('tomsmith', 'SuperSecretPassword!')
    expect(@login.success_message_present?).to be_truthy
  end

  it 'failed' do
    @login.with('asdf', 'asdf')
    expect(@login.failure_message_present?).to be_truthy
  end

end
```

```ruby
# filename: spec/dynamic_loading_spec.rb
require_relative 'spec_helper'
require_relative '../pages/dynamic_loading'

describe 'Dynamic Loading' do

  before(:each) do
    @dynamic_loading = DynamicLoading.new(@driver)
  end

  it 'Example 1: Hidden Element' do
    @dynamic_loading.load '1'
    expect(@dynamic_loading.finish_text_present?).to be_truthy
  end

  it 'Example 2: Rendered after the fact' do
    @dynamic_loading.load '2'
    expect(@dynamic_loading.finish_text_present?).to be_truthy
  end

end
```

## Base URL

Up until now we've been hard-coding the URL we want to use for our application. But it's likely that the application could have numerous URL end-points. In the case of [the-internet](https://github.com/tourdedave/the-internet) there is the production URL (e.g., `http://the-internet.herokuapp.com`) and then there's running the app locally (e.g., `http://localhost:4567`).

In order to service both of these URLs with our tests we'll want to make it so we can specify a base URL at runtime and update our page objects to use it. We'll also want to set a sensible default for the base URL so if we specify nothing, a valid URL will be provided to our tests. So let's create a central file to store configuration values like this and make sure it can receive values at runtime. Let's create a `config.rb` file in the `spec` directory and place it there.

```sh
├── Gemfile
├── pages
│   ├── base_page.rb
│   ├── dynamic_loading.rb
│   └── login.rb
├── spec
│   ├── config.rb
│   ├── dynamic_loading_spec.rb
│   ├── login_spec.rb
│   └── spec_helper.rb
└── vendor
    └── geckodriver
```

```ruby
# filename: config.rb
module Config
  def config
    { base_url: ENV['BASE_URL'] || 'http://the-internet.herokuapp.com' }
  end
end
```

By using a `module` we'll be able to easily mix it into where we need it. And with the help of a conditional when setting the `base_url` (e.g., `||=`) we're able to get our sensible default.

We are making it so we can override this value when launching our test suite (by specifying a value for the environment variable `BASE_URL`). It essentially means if the environment variable already exists and contains a value, use it. Otherwise, use `'http://the-internet.herokuapp.com'`. This will come in handy later, and is an approach we'll use frequently.

With the base URL in a central place we can now go and update our page objects to use it.

```ruby
# filename: pages/base_page.rb
require_relative '../spec/config'

class BasePage
  include Config

	# ...

  def visit(url)
    if url.start_with? 'http'
      @driver.get url
    else
      @driver.get config[:base_url] + url
    end
  end
# ...
```

In our base page object we put the config to use by mixing it in (e.g., `include Config`) and referencing it in `visit`. If the `url` provided starts with `http`, then we do what we've been doing. Otherwise, we create a URL with the base URL and what's provided in `url`.

Now to update our page objects to just provide a URL path when calling `visit`.

```ruby
# filename: pages/dynamic_loading.rb
# ...
  def example(example_number)
    visit "/dynamic_loading/#{example_number}"
  end
# ...
```

```ruby
# filename: pages/login.rb
# ...
  def initialize(driver)
    super
    visit '/login'
    raise 'Login page not ready' unless
      is_displayed?(LOGIN_FORM)
  end
# ...
```

Now our page objects are free from hard-coded URLs, making our tests more flexible.

## Running Everything

Now that things are cleaned up, let's run everything to make sure the tests still pass (e.g., `rspec` from the command line).

To specify a different base URL, prepend the command with it (e.g., `base_url=http://localhost:4567 rspec` if you had a local instance of [the-internet](https://github.com/tourdedave/the-internet) running).


